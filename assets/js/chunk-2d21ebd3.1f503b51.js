(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21ebd3"],{d79c:function(n,t,e){"use strict";e.r(t);var c=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("el-main",{staticClass:"center"},[e("h3",[n._v("Javascript 中 var 声明和 function声明区别")]),e("p",[n._v("示例 1")]),e("vue-code",[e("pre",{attrs:{lang:"js"}},[n._v("// 函数表达式(function expression) \nvar h1 = function () {\n    // h1\n}\n\n// 函数声明(function declaration) \nfunction h2() {\n    // h2\n} ")])]),e("p",[n._v("先说两者的显著区别:")]),e("p",[n._v("第一种声明方式也就是var声明方式, 函数只有在var语句声明之后才能被调用")]),e("p",[n._v("第二种生命方式也就是function声明方式, 函数可以在function声明之前被调用")]),e("p",[n._v("这是因为:")]),e("p",[n._v("对第一种情况, 函数表达式是在函数运行阶段才赋值给变量h")]),e("p",[n._v("对第二种情况, 函数表达式是在代码运行阶段之前, 也就是代码解析阶段才赋值给标识符h")]),e("p",[e("br"),e("br"),n._v(" JS声明函数的三种方式:"),e("br"),n._v(' 1. 函数表达式: 即上面第一种方式, 这种方法使用function操作符创建函数, 表达式可以存储在变量或者对象属性里. 函数表达式往往被称为 匿名函数, 因为它没有名字. 证明这一点你可以 console.log(h.name); 可以看到打印为空 ""; '),e("br"),n._v(' 2. 函数声明: 即上面第二种方式, 会声明一个具名函数, 且函数能在其所在作用域的任意位置被调用, 其创建的函数为具名函数, 证明这一 点你可以 console.log(h.name); 可以看到打印为 "h". 可在后面的代码中将此函数通过函数名赋值给变量或者对象属性'),e("br"),n._v(" 3. Function()构造器: 不推荐这种用法, 容易出问题"),e("br")]),e("p",[e("a",{attrs:{href:"https://www.jb51.net/article/135701.htm"}},[n._v("更多阅读")])])],1)},a=[],r=e("d4ec"),o=e("bee2"),i=e("262e"),u=e("2caf"),v=e("9ab4"),p=e("1b40"),s=function(n){Object(i["a"])(e,n);var t=Object(u["a"])(e);function e(){return Object(r["a"])(this,e),t.apply(this,arguments)}return Object(o["a"])(e,[{key:"example1",value:function(){}}]),e}(p["l"]);s=Object(v["a"])([Object(p["a"])({name:"JavaScriptScoped"})],s);var l=s,f=l,b=e("2877"),h=function(n){n.options.__source="src/tutorial/views/articles/JavaScriptScoped.vue"},_=h,d=Object(b["a"])(f,c,a,!1,null,"0addf9c0",null);"function"===typeof _&&_(d);t["default"]=d.exports}}]);