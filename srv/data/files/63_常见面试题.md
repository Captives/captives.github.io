
## JavaScript

### 原型链和作用域链的区别

1. 原型链
当访问一个对象的某个属性时，会先在这个对象本身的属性上找，如果没有找到，会去这个属性的__proto__属性上找，即这个构造函数的prototype，如果还没找到，就会继续在__proto__上查找，直到最顶层，找不到即为undefined。这样一层一层往上找，彷佛是一条链子串起来，所以叫做原型链。

2. 作用域链
变量取值会到创建这个变量的函数的作用域中取值，如果找不到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

3. 区别
作用域是对变量而言，原型链是对于对象的属性而言
作用域链的顶层是window，原型链的顶层是Object

### js 判断类型
1、typeof
检测不出==null==和==数组==,==对象==，结果都为`object`，所以`typeof`常用于检测基本类型
```js
1 "number"
124 string
null "object" //null值表示一个空对象指针
true "boolean"
[1, 2, 3] "object"
new Date() "object"
```
2、instanceof
不能检测出==number==、==boolean==、==string==、==undefined==、==null==、==symbol==类型，所以`instancof`常用于检测复杂类型以及级成关系

`instanceof`运算符用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上。
```js
const f = true;
const h = [1, 2, 3];
const i = new Date();

console.log(f, f instanceof Boolean); //false
console.log(h, h instanceof Array); //true
console.log(i, i instanceof Date); //true
```

3、constructor
==null==、==undefined==没有==construstor==方法，因此`constructor`不能判断==undefined==和==null==。但是`contructor`的指向是可以被改变，所以不安全
```js
console.log([1, 2].constructor === Array) // ture
```

4、Object.prototype.toString.call
全类型都可以判断
```js
Object.prototype.toString.call([1, 2]) // [object Array]
```

### 普通函数和箭头函数的区别
1、普通函数
可以通过bind、call、apply改变this指向
可以使用new

2、箭头函数
本身没有this指向，
它的this在定义的时候继承自外层第一个普通函数的this
被继承的普通函数的this指向改变，箭头函数的this指向会跟着改变
箭头函数外层没有普通函数时，this指向window
不能通过bind、call、apply改变this指向
使用new调用箭头函数会报错，因为箭头函数没有constructor

### document.write和innerHTML的区别
document.write 将内容写入页面，清空替换掉原来的内容，会导致重绘
document.innerHTML 将内容写入某个Dom节点，不会重绘

### 栈和堆的区别
1、堆
动态分配内存，内存大小不一，也不会自动释放

2、栈
自动分配相对固定大小的内存空间，并由系统自动释放

3、基本类型都是存储在栈中，每种类型的数据占用的空间的大小是确定的，并由系统自动分配和释放。内存可以及时回收。

4、引用类型的数据都是存储在堆中。准确说是栈中会存储这些数据的地址指针，并指向堆中的具体数据。

### undefined 和 null 区别
1、null
什么都没有，表示一个空对象引用（主动释放一个变量引用的兑现那个，表示一个变量不再指向任何引用地址）
2、undefined
没有设置值的变量，会自动赋值undefined
3、区别
typeof undefined             // undefined
typeof null                  // object
null === undefined           // false
null == undefined            // true

### eval()
eval(string) 函数计算`JavaScript`字符串，并把它作为脚本代码来执行
如果参数是一个表达式，`eval()`函数将执行表达式；
如果参数是`Javascript`语句，`eval()`将执行`Javascript`语句；
如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。
特殊：eval("{b:2}") // 声明一个对象
　eval("（{b:2}）") // 返回对象{b:2}

### JS哪些操作会造成内存泄露
内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。
1、意外的全局变量
2、闭包
3、没有清理的dom元素；dom元素赋值给变量，又通过removeChild移除dom元素。但是dom元素的引用还在内存中
4、被遗忘的定时器或者回调
[扩展文章](https://www.jianshu.com/p/763ba9562864)

### 什么是闭包，如何使用它，为什么要使用它？

（1）闭包就是能够读取其它函数内部变量的函数
（2）使用方法：在一个函数内部创建另一个函数
（3）最大用处有两个：读取其他函数的变量值，让这些变量始终保存在内存中
（4）缺点：会引起内存泄漏（引用无法被销毁，一直存在）

### 请解释JSONP的工作原理，以及它为什么不是真正的AJAX
JSONP 是一种非正式传输协议，允许用户传递一个callback给服务端，然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。
它们的实质不同
ajax的核心是通过xmlHttpRequest获取非本页内容
jsonp的核心是动态添加script标签调用服务器提供的js脚本
jsonp只支持get请求，ajax支持get和post请求

### 请解释一下JavaScript的同源策略
同源指协议，域名，端口相同，
同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。




## 面试题

### 写出如下代码的打印结果
```js
var name = 'Tom';
(function() {
if (typeof name == 'undefined') {
  var name = 'Jack';
  console.log('Goodbye ' + name);
} else {
  console.log('Hello ' + name);
}
})();

// name undefined
// typeof name undefined
// Goodbye Jack
```
第四行`var`声明的变量没有块作用域，变量会提升到最近的`function`作用域的上层，但此时只是声明了变量，并没有赋值，到实际运行了赋值语句之后才有值，在之前值为`undefined`;
```js
var name = 'Tom';
(function() {
if (typeof name == 'undefined') {
  name = 'Jack';
  console.log('Goodbye ' + name);
} else {
  console.log('Hello ' + name);
}
})();

// Hello Tom
```
1、首先在进入函数作用域当中，获取name属性 
2、在当前作用域没有找到name 
3、通过作用域链找到最外层，得到name属性 
4、执行else的内容，得到Hello Tom


### 输出以下代码运行结果

```js
1 + "1"				// '11'

2 * "2"				// 4
	
[1, 2] + [2, 1]			// '1,22,1'

"a" + + "b"			// 'aNaN'
```

1 + "1"
加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来
所以值为：“11”

2 * "2"
乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值

[1, 2] + [2, 1]
Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。
所以两个数组对象的toString方法相加，值为："1,22,1"

"a" + + "b"
后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。
所以值为："aNaN"

以上均参考：《Javascript高级程序设计》
