<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/code-style.css">
    <link rel="stylesheet" href="/css/page.css">
    <title>Lodash 集合 Collection</title>
</head>

<body>
    <div class="content"><h1><a id="集合"></a>集合</h1>
<h2><a id="创建"></a>创建</h2>
<h3><a id="_.sample(collection)"></a>_.sample(collection)</h3>
<p>从<code>collection</code>（集合）中获得一个随机元素。</p>
<pre><div class="hljs"><code class="lang-js">_.sample([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);
<span class="hljs-comment">// =&gt; 2</span>
</code></div></pre>
<h3><a id="_.sampleSize(collection, [n = 1])"></a>_.sampleSize(collection, [n = 1])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 要取样的集合。</li>
<li>[n=1] (number): 取样的元素个数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回随机元素。</li>
</ul>
</details></div><p>从<code>collection</code>中获得<code>n</code>个随机元素。</p>
<pre><div class="hljs"><code class="lang-js">_.sampleSize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; [3, 1]</span>
 
_.sampleSize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>);
<span class="hljs-comment">// =&gt; [2, 3, 1]</span>
</code></div></pre>
<h3><a id="_.shuffle(collection)"></a>_.shuffle(collection)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 要打乱的集合。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回打乱的新数组。</li>
</ul>
</details></div><p>创建一个被打乱值的集合。 使用<a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle" target="_blank">Fisher-Yates shuffle</a>版本。</p>
<pre><div class="hljs"><code class="lang-js">_.shuffle([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);
<span class="hljs-comment">// =&gt; [4, 1, 3, 2]</span>
</code></div></pre>
<h3><a id="_.countBy(collection, [iteratee = _.identity])"></a>_.countBy(collection, [iteratee = _.identity])</h3>
<p>创建一个组成对象；<br />
key（键）是经过 iteratee（迭代函数）执行处理<code>collection</code>中每个元素后返回的结果；<br />
每个key（键）对应的<code>value</code>值：是<code>iteratee(value)</code>（迭代函数）返回该key（键）的迭代次数。</p>
<pre><div class="hljs"><code class="lang-js">_.countBy([<span class="hljs-number">6.1</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">6.3</span>], <span class="hljs-built_in">Math</span>.floor);
<span class="hljs-comment">// =&gt; { '4': 1, '6': 2 }</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.countBy([<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>], <span class="hljs-string">'length'</span>);
<span class="hljs-comment">// =&gt; { '3': 2, '5': 1 }</span>
</code></div></pre>
<h3><a id="_.sortBy(collection, [iteratees = [ _.identity ] ])"></a>_.sortBy(collection, [iteratees = [ _.identity ] ])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[iteratees=[_.identity]] (…(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])): 这个函数决定排序。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回排序后的数组。</li>
</ul>
</details></div><p>创建一个元素数组。<br />
以<code>iteratee(value)</code>处理的结果升序排序。 这个方法执行稳定排序，也就是说相同元素会保持原始排序。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">48</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">34</span> }
];
 
_.sortBy(users, item =&gt; item.user);
<span class="hljs-comment">// =&gt; objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]</span>
 
_.sortBy(users, [<span class="hljs-string">'user'</span>, <span class="hljs-string">'age'</span>]);
<span class="hljs-comment">// =&gt; objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]</span>
 
_.sortBy(users, <span class="hljs-string">'user'</span>, item =&gt; <span class="hljs-built_in">Math</span>.floor(item.age / <span class="hljs-number">10</span>));
<span class="hljs-comment">// =&gt; objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]</span>
</code></div></pre>
<h3><a id="_.orderBy(collection, [iteratees=[ _.identity ] ], [ orders ])"></a>_.orderBy(collection, [iteratees=[ _.identity ] ], [ orders ])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[iteratees=[_.identity]] (Array[]|Function[]|Object[]|string[]): 排序的迭代函数。</li>
<li>[orders] (string[]): iteratees迭代函数的排序顺序。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 排序排序后的新数组。</li>
</ul>
</details></div><p>此方法类似于<code>_.sortBy</code>，除了它允许指定<code>iteratee</code>（迭代函数）结果如何排序。 如果没指定orders，以默认值&quot;asc&quot; 升序；否则为&quot;desc&quot; 降序排序对应值。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">48</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">34</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span> }
];
 
<span class="hljs-comment">// 以 `user` 升序排序 再  `age` 以降序排序。</span>
_.orderBy(users, [<span class="hljs-string">'user'</span>, <span class="hljs-string">'age'</span>], [<span class="hljs-string">'asc'</span>, <span class="hljs-string">'desc'</span>]);
<span class="hljs-comment">// =&gt; [{"user":"barney","age":36},{"user":"barney","age":34},{"user":"fred","age":48},{"user":"fred","age":40}]</span>
</code></div></pre>
<h3><a id="_.groupBy(collection, [iteratee = _.identity])"></a>_.groupBy(collection, [iteratee = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[iteratee=_.identity] (Array|Function|Object|string): 这个迭代函数用来转换key。</li>
</ul>
<p>返回</p>
<ul>
<li>(Object): 返回一个组成聚合的对象。</li>
</ul>
</details></div><p>创建一个对象;<br />
<code>key</code>是<code>iteratee(value)</code>遍历<code>collectio</code>中的每个元素返回的结果。 分组值的顺序是由他们出现在<code>collection</code>中的顺序确定的。每个键对应的值负责生成<code>key</code>的元素组成的数组。</p>
<pre><div class="hljs"><code class="lang-js">_.groupBy([<span class="hljs-number">6.1</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">6.3</span>], <span class="hljs-built_in">Math</span>.floor);
<span class="hljs-comment">// =&gt; { '4': [4.2], '6': [6.1, 6.3] }</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.groupBy([<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>], <span class="hljs-string">'length'</span>);
<span class="hljs-comment">// =&gt; { '3': ['one', 'two'], '5': ['three'] }</span>
</code></div></pre>
<h3><a id="_.keyBy(collection, [iteratee = _.identity])"></a>_.keyBy(collection, [iteratee = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[iteratee=_.identity] (Array|Function|Object|string): 这个迭代函数用来转换key。</li>
</ul>
<p>返回</p>
<ul>
<li>(Object): 返回一个组成聚合的对象。</li>
</ul>
</details></div><p>创建一个对象; 组成<code>key</code>是<code>collection</code>中的每个元素经过<code>iteratee(value)</code>处理后返回的结果。 每个<code>key</code>对应的值是生成<code>key</code>的最后一个元素。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> array = [
  { <span class="hljs-string">'dir'</span>: <span class="hljs-string">'left'</span>, <span class="hljs-string">'code'</span>: <span class="hljs-number">97</span> },
  { <span class="hljs-string">'dir'</span>: <span class="hljs-string">'right'</span>, <span class="hljs-string">'code'</span>: <span class="hljs-number">100</span> }
];
 
_.keyBy(array, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(o.code);
});
<span class="hljs-comment">// =&gt; { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }</span>
 
_.keyBy(array, <span class="hljs-string">'dir'</span>);
<span class="hljs-comment">// =&gt; { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }</span>
</code></div></pre>
<h2><a id="遍历"></a>遍历</h2>
<h3><a id="_.forEach(collection, [iteratee = _.identity])"></a>_.forEach(collection, [iteratee = _.identity])</h3>
<blockquote>
<p>别名 _.each</p>
</blockquote>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[iteratee=_.identity] (Function): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(*): 返回集合 collection。</li>
</ul>
</details></div><p>调用<code>iteratee</code>遍历<code>collection</code>(集合)中的每个元素，<code>iteratee</code>调用3个参数： <code>(value, index|key, collection)</code>。 如果迭代函数<code>iteratee</code>显式的返回false，迭代会提前退出。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>与其他&quot;集合&quot;方法一样，类似于数组，对象的 “length” 属性也会被遍历。<br />
想避免这种情况，可以用<a href="https://www.lodashjs.com/docs/lodash.forIn" target="_blank">_.forIn</a>或者<a href="https://www.lodashjs.com/docs/lodash.forOwn" target="_blank">_.forOwn</a>代替。</p>
</div><pre><div class="hljs"><code class="lang-js">_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-built_in">console</span>.log(value);
});
<span class="hljs-comment">// =&gt; 顺序输出1、2.</span>
 
_.forEach({ <span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
  <span class="hljs-built_in">console</span>.log(key);
});
<span class="hljs-comment">// =&gt; 随机输出 a、b，不保证顺序</span>
</code></div></pre>
<h3><a id="_.forEachRight(collection, [iteratee = _.identity])"></a>_.forEachRight(collection, [iteratee = _.identity])</h3>
<blockquote>
<p>别名：_.eachRight</p>
</blockquote>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[iteratee=_.identity] (Function): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(*): 返回集合 collection。</li>
</ul>
</details></div><p>这个方法类似<code>_.forEach</code>，不同之处在于<code>_.forEachRight</code>是从右到左遍历集合中每一个元素的。</p>
<pre><div class="hljs"><code class="lang-js">_.forEachRight([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-built_in">console</span>.log(value);
});
<span class="hljs-comment">// =&gt; 顺序输出1、2.</span>
</code></div></pre>
<h3><a id="_.map(collection, [iteratee = _.identity])"></a>_.map(collection, [iteratee = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[iteratee=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回新的映射后数组。</li>
</ul>
</details></div><p>创建一个数组，<code>value</code> 是<code>iteratee(value, index|key, collection)</code>遍历<code>collection</code>中的每个元素后返回的结果。</p>
<div class='tip-block warning'><p>lodash 中有许多方法是防止作为其他方法的迭代函数。<br />
例如：<br />
_.every, _.filter, _.map, _.mapValues, _.reject和 _.some</p>
<p>注：即不能作为iteratee参数传递给其他方法</p>
<p>受保护的方法有：<br />
ary, chunk, curry, curryRight, drop, dropRight, every,fill, invert, parseInt, random, range, rangeRight, repeat,sampleSize, slice, some, sortBy, split, take, takeRight,template, trim, trimEnd, trimStart, and words</p>
<p>注：即这些方法不能使用 _.every, _.filter, _.map, _.mapValues, _.reject, 和 _.some作为iteratee迭代函数参数</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n * n;
}
 
_.map([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>], square);
<span class="hljs-comment">// =&gt; [16, 64]</span>
 
_.map({ <span class="hljs-string">'a'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">8</span> }, square);
<span class="hljs-comment">// =&gt; [16, 64] (iteration order is not guaranteed)</span>
 
<span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span> }
];
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.map(users, <span class="hljs-string">'user'</span>);
<span class="hljs-comment">// =&gt; ['barney', 'fred']</span>
</code></div></pre>
<h2><a id="检索"></a>检索</h2>
<h3><a id="_.includes(collection, value, [fromIndex = 0])"></a>_.includes(collection, value, [fromIndex = 0])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object|string): 要检索的集合。</li>
<li>value (*): 要检索的值。</li>
<li>[fromIndex=0] (number): 要检索的 索引位置。</li>
</ul>
<p>返回</p>
<ul>
<li>(boolean): 如果找到 value 返回 true， 否则返回 false。</li>
</ul>
</details></div><p>检查<code>value</code>是否在<code>collection</code>中。如果<code>collection</code>是一个字符串，那么检查<code>value</code>(子字符串）是否在字符串中，否则使用<a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero" target="_blank">SameValueZero</a>做等值比较。 如果指定<code>fromIndex</code>是负数，那么从<code>collection</code>的结尾开始检索。</p>
<pre><div class="hljs"><code class="lang-js">_.includes([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">1</span>);
<span class="hljs-comment">// =&gt; true</span>
 
_.includes([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; false</span>
 
_.includes({ <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span> }, <span class="hljs-string">'fred'</span>);
<span class="hljs-comment">// =&gt; true</span>
 
_.includes(<span class="hljs-string">'pebbles'</span>, <span class="hljs-string">'eb'</span>);
<span class="hljs-comment">// =&gt; true</span>
</code></div></pre>
<h3><a id="_.every(collection, [predicate = _.identity])"></a>_.every(collection, [predicate = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(boolean): 如果所有元素经 predicate（断言函数） 检查后都都返回真值，那么就返回true，否则返回 false 。</li>
</ul>
</details></div><p>通过<code>predicate</code>（断言函数）检查<code>collection</code>（集合）中的所有元素是否都返回true。一旦<code>predicate</code>（断言函数）返回false，迭代就马上停止。</p>
<p><code>predicate(value, index | key, collection)</code>。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>这个方法对于对于<a href="https://en.wikipedia.org/wiki/Empty_set" target="_blank">空集合</a>返回 true，因为空集合的<a href="https://en.wikipedia.org/wiki/Vacuous_truth" target="_blank">任何元素都是true</a> 。</p>
</div><pre><div class="hljs"><code class="lang-js">_.every([<span class="hljs-literal">true</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'yes'</span>], <span class="hljs-built_in">Boolean</span>);
<span class="hljs-comment">// =&gt; false</span>
 
<span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> }
];
 
<span class="hljs-comment">// The `_.matches` iteratee shorthand.</span>
_.every(users, { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// =&gt; false</span>
 
<span class="hljs-comment">// The `_.matchesProperty` iteratee shorthand.</span>
_.every(users, [<span class="hljs-string">'active'</span>, <span class="hljs-literal">false</span>]);
<span class="hljs-comment">// =&gt; true</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.every(users, <span class="hljs-string">'active'</span>);
<span class="hljs-comment">// =&gt; false</span>
</code></div></pre>
<h3><a id="_.some(collection, [predicate = _.identity])"></a>_.some(collection, [predicate = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(boolean): 如果任意元素经 predicate 检查都为 truthy（真值），返回 true ，否则返回 false 。</li>
</ul>
</details></div><p>通过<code>predicate</code>（断言函数）检查<code>collection</code>（集合）中的元素是否存在<strong>任意</strong> truthy（真值）的元素，一旦<code>predicate</code>（断言函数）返回 truthy（真值），遍历就停止。</p>
<p><code>predicate(value, index | key, collection)</code>。</p>
<pre><div class="hljs"><code class="lang-js">_.some([<span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'yes'</span>, <span class="hljs-literal">false</span>], <span class="hljs-built_in">Boolean</span>);
<span class="hljs-comment">// =&gt; true</span>
 
<span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> }
];
 
<span class="hljs-comment">// The `_.matches` iteratee shorthand.</span>
_.some(users, { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// =&gt; false</span>
 
<span class="hljs-comment">// The `_.matchesProperty` iteratee shorthand.</span>
_.some(users, [<span class="hljs-string">'active'</span>, <span class="hljs-literal">false</span>]);
<span class="hljs-comment">// =&gt; true</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.some(users, <span class="hljs-string">'active'</span>);
<span class="hljs-comment">// =&gt; true</span>
</code></div></pre>
<h3><a id="_.find(collection, [predicate = _.identity], [fromIndex = 0])"></a>_.find(collection, [predicate = _.identity], [fromIndex = 0])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[predicate = _.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
<li>[fromIndex = 0] (number): 开始搜索的索引位置。</li>
</ul>
<p>返回</p>
<ul>
<li>(*): 返回匹配元素，否则返回 undefined。</li>
</ul>
</details></div><p>遍历<code>collection</code>（集合）元素，返回<code>predicate</code>（断言函数）第一个返回true的第一个元素。</p>
<p><code>predicate(value, index | key, collection)</code></p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>,  <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,    <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'pebbles'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">1</span>,  <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> }
];
 
_.find(users, item =&gt; item.age &lt; <span class="hljs-number">40</span>);
<span class="hljs-comment">// =&gt; object for 'barney'</span>
 
<span class="hljs-comment">// The `_.matches` iteratee shorthand.</span>
_.find(users, { <span class="hljs-string">'age'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">// =&gt; object for 'pebbles'</span>
 
<span class="hljs-comment">// The `_.matchesProperty` iteratee shorthand.</span>
_.find(users, [<span class="hljs-string">'active'</span>, <span class="hljs-literal">false</span>]);
<span class="hljs-comment">// =&gt; object for 'fred'</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.find(users, <span class="hljs-string">'active'</span>);
<span class="hljs-comment">// =&gt; object for 'barney'</span>
</code></div></pre>
<h3><a id="_.findLast(collection, [predicate = _.identity], [fromIndex = collection.length - 1])"></a>_.findLast(collection, [predicate = _.identity], [fromIndex = collection.length - 1])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
<li>[fromIndex=collection.length-1] (number): 开始搜索的索引位置。</li>
</ul>
<p>返回</p>
<ul>
<li>(*): 返回匹配元素，否则返回 undefined。</li>
</ul>
</details></div><p>这个方法类似<code>_.find</code>，不同之处在于，<code>_.findLast</code>是从右至左遍历<code>collection</code>元素的。</p>
<pre><div class="hljs"><code class="lang-js">_.findLast([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>);
<span class="hljs-comment">// =&gt; 3</span>
</code></div></pre>
<h2><a id="过滤"></a>过滤</h2>
<h3><a id="_.filter(collection, [predicate = _.identity])"></a>_.filter(collection, [predicate = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回一个新的过滤后的数组。</li>
</ul>
</details></div><p>遍历<code>collection</code>（集合）元素，返回<code>predicate</code>（断言函数）返回true的所有元素的数组。</p>
<p><code>predicate(value, index | key, collection)</code></p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> }
];
 
_.filter(users, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{ <span class="hljs-keyword">return</span> !o.active; });
<span class="hljs-comment">// =&gt; objects for ['fred']</span>
 
<span class="hljs-comment">// The `_.matches` iteratee shorthand.</span>
_.filter(users, { <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">// =&gt; objects for ['barney']</span>
 
<span class="hljs-comment">// The `_.matchesProperty` iteratee shorthand.</span>
_.filter(users, [<span class="hljs-string">'active'</span>, <span class="hljs-literal">false</span>]);
<span class="hljs-comment">// =&gt; objects for ['fred']</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.filter(users, <span class="hljs-string">'active'</span>);
<span class="hljs-comment">// =&gt; objects for ['barney']</span>
</code></div></pre>
<h3><a id="_.reject(collection, [predicate = _.identity])"></a>_.reject(collection, [predicate = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回过滤后的新数组</li>
</ul>
</details></div><p><code>_.filter</code>的反向方法;<br />
此方法通过<code>predicate</code>（断言函数）不返回 <code>truthy</code>（真值）的<code>collection</code>元素（注释：非真）。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,   <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> }
];
 
_.reject(users, item =&gt; item.active);
<span class="hljs-comment">// =&gt; objects for ['fred']</span>
 
<span class="hljs-comment">// `_.matches` 迭代简写</span>
_.reject(users, { <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">// =&gt; objects for ['barney']</span>
 
<span class="hljs-comment">// `_.matchesProperty` 迭代简写</span>
_.reject(users, [<span class="hljs-string">'active'</span>, <span class="hljs-literal">false</span>]);
<span class="hljs-comment">// =&gt; objects for ['fred']</span>
 
<span class="hljs-comment">// `_.property` 迭代简写</span>
_.reject(users, <span class="hljs-string">'active'</span>);
<span class="hljs-comment">// =&gt; objects for ['barney']</span>
</code></div></pre>
<h3><a id="_.partition(collection, [predicate = _.identity])"></a>_.partition(collection, [predicate = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回元素分组后的数组。</li>
</ul>
</details></div><p>创建一个分成两组的元素数组，第一组包含<code>predicate(value)</code>（断言函数）返回为 <code>truthy</code>（真值）的元素，第二组包含<code>predicate</code>返回为<code>falsey</code>的元素。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> users = [
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'barney'</span>,  <span class="hljs-string">'age'</span>: <span class="hljs-number">36</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,    <span class="hljs-string">'age'</span>: <span class="hljs-number">40</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">true</span> },
  { <span class="hljs-string">'user'</span>: <span class="hljs-string">'pebbles'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">1</span>,  <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> }
];
 
_.partition(users, item =&gt; item.active);
<span class="hljs-comment">// =&gt; objects for [['fred'], ['barney', 'pebbles']]</span>
 
<span class="hljs-comment">// The `_.matches` iteratee shorthand.</span>
_.partition(users, { <span class="hljs-string">'age'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'active'</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// =&gt; objects for [['pebbles'], ['barney', 'fred']]</span>
 
<span class="hljs-comment">// The `_.matchesProperty` iteratee shorthand.</span>
_.partition(users, [<span class="hljs-string">'active'</span>, <span class="hljs-literal">false</span>]);
<span class="hljs-comment">// =&gt; objects for [['barney', 'pebbles'], ['fred']]</span>
 
<span class="hljs-comment">// The `_.property` iteratee shorthand.</span>
_.partition(users, <span class="hljs-string">'active'</span>);
<span class="hljs-comment">// =&gt; objects for [['fred'], ['barney', 'pebbles']]</span>
</code></div></pre>
<h2><a id="转换"></a>转换</h2>
<h3><a id="_.flatMap(collection, [iteratee = _.identity])"></a>_.flatMap(collection, [iteratee = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代遍历的集合。</li>
<li>[iteratee=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回新扁平化数组。</li>
</ul>
</details></div><p>创建一个<strong>扁平化</strong>（同阶数组）的数组，这个数组的值来自<code>collection</code>中每一个值经过<code>iteratee(value, index | key, collection)</code>处理后返回的结果，并且扁平化合并。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">duplicate</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> [n, n];
}
 
_.flatMap([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], duplicate);
<span class="hljs-comment">// =&gt; [1, 1, 2, 2]</span>
</code></div></pre>
<h3><a id="_.flatMapDeep(collection, [iteratee = _.identity])"></a>_.flatMapDeep(collection, [iteratee = _.identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[iteratee=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回新扁平化数组。</li>
</ul>
</details></div><p>这个方法类似<code>_.flatMap</code>不同之处在于，<code>_.flatMapDeep</code>会继续扁平化递归映射的结果。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">duplicate</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> [[[n, n]]];
}
 
_.flatMapDeep([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], duplicate);
<span class="hljs-comment">// =&gt; [1, 1, 2, 2]</span>
</code></div></pre>
<h3><a id="_.flatMapDepth(collection, [iteratee = _.identity], [depth = 1])"></a>_.flatMapDepth(collection, [iteratee = _.identity], [depth = 1])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 一个用来迭代的集合。</li>
<li>[iteratee=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。</li>
<li>[depth=1] (number): 最大递归深度。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回新扁平化数组。</li>
</ul>
</details></div><p>该方法类似<code>_.flatMap</code>，不同之处在于<code>_.flatMapDepth</code>会根据指定的 <code>depth</code>（递归深度）继续扁平化递归映射结果。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">duplicate</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> [[[n, n]]];
}
 
_.flatMapDepth([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], duplicate, <span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; [[1, 1], [2, 2]]</span>
</code></div></pre>
<h2><a id="其它"></a>其它</h2>
<h3><a id="_.invokeMap(collection, path, [args])"></a>_.invokeMap(collection, path, [args])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>path (Array|Function|string): 用来调用方法的路径 或 者每次迭代调用的函数。</li>
<li>[args] (…*): 调用每个方法的参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Array): 返回的结果数组。</li>
</ul>
</details></div><p>调用<code>path</code>（路径）上的方法处理<code>collection</code>中的每个元素，返回一个数组, 包含每次调用方法得到的结果。<br />
任何附加的参数提供给每个被调用的方法。如果<code>methodName</code>（方法名）是一个函数，每次调用函数时，内部的<code>this</code>指向集合中的每个元素。</p>
<pre><div class="hljs"><code class="lang-js">_.invokeMap([[<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]], <span class="hljs-string">'sort'</span>);
<span class="hljs-comment">// =&gt; [[1, 5, 7], [1, 2, 3]]</span>
 
_.invokeMap([<span class="hljs-number">123</span>, <span class="hljs-number">456</span>], <span class="hljs-built_in">String</span>.prototype.split, <span class="hljs-string">''</span>);
<span class="hljs-comment">// =&gt; [['1', '2', '3'], ['4', '5', '6']]</span>
</code></div></pre>
<h3><a id="_.reduce(collection, [iteratee = _.identity], [ accumulator ])"></a>_.reduce(collection, [iteratee = _.identity], [ accumulator ])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[iteratee=_.identity] (Function): 每次迭代调用的函数。</li>
<li>[accumulator] (*): 初始值。</li>
</ul>
<p>返回</p>
<ul>
<li>(*): 返回累加后的值。</li>
</ul>
</details></div><p>压缩<code>collection</code>为一个值，通过<code>iteratee(accumulator, value, index|key, collection)</code>遍历<code>collection</code>中的每个元素，每次返回的值会作为下一次迭代使用(作为<code>iteratee</code>的第一个参数使用)。 如果没有提供<code>accumulator</code>，则<code>collection</code>中的第一个元素作为初始值。(<code>accumulator</code>参数在第一次迭代的时候作为<code>iteratee</code>第一个参数使用。)</p>
<div class='tip-block warning'><p>lodash 中有许多方法是防止作为其他方法的迭代函数，例如：<br />
_.reduce, _.reduceRight 和 _.transform。<br />
注：即不能作为iteratee参数传递给其他方法</p>
<p>受保护的方法有：<br />
<code>assign</code>, <code>defaults</code>, <code>defaultsDeep</code>, <code>includes</code>, <code>merge</code>, <code>orderBy</code>和 <code>sortBy</code><br />
注：即这些方法不能使用 <code>_.reduce</code>, <code>_.reduceRight</code> 和 <code>_.transform</code>作为<code>iteratee</code>迭代函数参数</p>
</div><pre><div class="hljs"><code class="lang-js">_.reduce([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum, n</span>) </span>{
  <span class="hljs-keyword">return</span> sum + n;
}, <span class="hljs-number">0</span>);
<span class="hljs-comment">// =&gt; 3</span>
 
_.reduce({ <span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">1</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, value, key</span>) </span>{
  (result[value] || (result[value] = [])).push(key);
  <span class="hljs-keyword">return</span> result;
}, {});
<span class="hljs-comment">// =&gt; { '1': ['a', 'c'], '2': ['b'] } (无法保证遍历的顺序)</span>
</code></div></pre>
<h3><a id="_.reduceRight(collection, [iteratee = _.identity], [accumulator])"></a>_.reduceRight(collection, [iteratee = _.identity], [accumulator])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>collection (Array|Object): 用来迭代的集合。</li>
<li>[iteratee=_.identity] (Function): 每次迭代调用的函数。</li>
<li>[accumulator] (*): 初始值。</li>
</ul>
<p>返回</p>
<ul>
<li>(*): 返回累加后的值。</li>
</ul>
</details></div><p>这个方法类似<code>_.reduce</code>，除了它是从右到左遍历<code>collection</code>中的元素的。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> array = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]];
 
_.reduceRight(array, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flattened, other</span>) </span>{
  <span class="hljs-keyword">return</span> flattened.concat(other);
}, []);
<span class="hljs-comment">// =&gt; [4, 5, 2, 3, 0, 1]</span>
</code></div></pre>
<h3><a id="_.size(collection)"></a>_.size(collection)</h3>
<p>返回<code>collection</code>的长度，如果集合是类数组或字符串，返回其<code>length</code>；如果集合是对象，返回其可枚举属性的个数。</p>
<pre><div class="hljs"><code class="lang-js">_.size([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// =&gt; 3</span>
 
_.size({ <span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span> });
<span class="hljs-comment">// =&gt; 2</span>
 
_.size(<span class="hljs-string">'pebbles'</span>);
<span class="hljs-comment">// =&gt; 7</span>
</code></div></pre>
</div>
</body>
<script src="/js/prism.js"></script>
<script>
    window.onload = function() {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
    }
</script>

</html>