<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/code-style.css">
    <link rel="stylesheet" href="/css/page.css"> 
    <title>数组 Array</title>
</head>

<body>
    
    <div class="content"><h1><a id="数组 Array"></a>数组 Array</h1>
<h2><a id="基础"></a>基础</h2>
<h3><a id="map"></a>map</h3>
<blockquote>
<p>array.map(function(currentValue, index, arr), thisValue)</p>
</blockquote>
<p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<br />
map() 方法按照原始数组元素顺序依次处理元素。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">56</span>, <span class="hljs-number">48</span>, <span class="hljs-number">14</span>, <span class="hljs-number">43</span>, <span class="hljs-number">-10</span>];

list.map(<span class="hljs-built_in">String</span>);
<span class="hljs-comment">// [ '3',  '5',  '2', '15', '4',  '0', '7',  '56', '48', '14', '43', '-10']</span>

list.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">0</span>);
<span class="hljs-comment">// [true, true, true, true, true, false, true, true, true, true, true, false]</span>
</code></div></pre>
<div class='tip-block warning'><p>map() 不会对空数组进行检测。<br />
map() 不会改变原始数组。</p>
</div><h3><a id="reduce"></a>reduce</h3>
<blockquote>
<p>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p>
</blockquote>
<p><code>reduce()</code>方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br />
<code>reduce()</code>可以作为一个高阶函数，用于函数的 compose。</p>
<div class='tip-block warning'><p>reduce() 对于空数组是不会执行回调函数的。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">56</span>, <span class="hljs-number">48</span>, <span class="hljs-number">14</span>, <span class="hljs-number">43</span>, <span class="hljs-number">-10</span>];
<span class="hljs-keyword">let</span> result = list.reduce(<span class="hljs-function">(<span class="hljs-params">t, c</span>) =&gt;</span> t + c);
<span class="hljs-comment">//187</span>
</code></div></pre>
<h3><a id="filter"></a>filter</h3>
<blockquote>
<p>array.filter(function(currentValue, index, arr), thisValue)</p>
</blockquote>
<p>filter() 方法创建一个新的数组，新数组中的元素是, 通过检查指定数组中符合条件的所有元素。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">56</span>, <span class="hljs-number">48</span>, <span class="hljs-number">14</span>, <span class="hljs-number">43</span>, <span class="hljs-number">-10</span>];

<span class="hljs-keyword">let</span> result = list.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(result);
<span class="hljs-comment">// [3, 5, 2, 15, 4, 7, 56, 48, 14, 43]</span>
<span class="hljs-built_in">console</span>.log(list);
<span class="hljs-comment">// [3, 5, 2, 15, 4, 0, 7, 56, 48, 14, 43, -10]</span>
</code></div></pre>
<div class='tip-block warning'><p>map() 不会对空数组进行检测。<br />
map() 不会改变原始数组。</p>
</div><h3><a id="sort"></a>sort</h3>
<blockquote>
<p>array.sort(sortby)</p>
</blockquote>
<p>用于对数组的元素进行排序。<br />
返回对数组的引用。只在原数组上进行排序，不生成副本。</p>
<pre><div class="hljs"><code class="lang-js">list.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 正序</span>
<span class="hljs-comment">//[-10, 0, 2, 3, 4, 5, 7, 14, 15, 43, 48, 56]</span>

list.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a); <span class="hljs-comment">// 倒序</span>
<span class="hljs-comment">//[56, 48, 43, 15, 14, 7, 5, 4, 3, 2, 0, -10]</span>
</code></div></pre>
<p>英文字符串排序</p>
<pre><div class="hljs"><code class="lang-js">list.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (a &lt; b) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">if</span> (a &gt; b) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
});
</code></div></pre>
<h2><a id="数据交换"></a>数据交换</h2>
<h3><a id="普通做法"></a>普通做法</h3>
<p>就是引入临时变量tmp,适用范围广；是最简单、直观、也是最高效的；但是，会增加内存的使用。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">let</span> c = a;
    a = b;
    b = c;
    <span class="hljs-keyword">return</span> [a, b];
}
</code></div></pre>
<h3><a id="算术运算"></a>算术运算</h3>
<p>适用范围，仅支持数字；<br />
通过算术运算过程中的技巧，可以巧妙地将两个值进行互换。但是，有个缺点就是变量数据溢出。因为JavaScript能存储数字的精度范围是-253到253。所以，加法运算，会存在溢出的问题。<br />
方式一：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    a = a + b;
    b = a - b;
    a = a - b;
    <span class="hljs-keyword">return</span> [a, b];
}

</code></div></pre>
<p>方式二：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
     a = b - a + (b = a); <span class="hljs-comment">//等价于方式三</span>
    <span class="hljs-keyword">return</span> [a, b];
}

</code></div></pre>
<p>方式三：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">let</span> c = b;
    b = a;
    a = c - a + b;
    <span class="hljs-keyword">return</span> [a, b];
}
</code></div></pre>
<h3><a id="数组方式"></a>数组方式</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    a = [a, b]; 
    b = a[<span class="hljs-number">0</span>];
    a = a[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> [a, b];
}
</code></div></pre>
<p>等价于</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    a = [b, b = a][<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> [a, b];
}
</code></div></pre>
<h3><a id="对象方式"></a>对象方式</h3>
<p>和数组方式类似，利用对象的键值对进行数据交换。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    a = { <span class="hljs-attr">a</span>: b, <span class="hljs-attr">b</span>: a };
    b = a.b;
    a = a.a;
    <span class="hljs-keyword">return</span> [a, b]; 
}
</code></div></pre>
<h3><a id="ES6解构"></a>ES6解构</h3>
<p>用解构的语法特性，一次性解决，简单暴力，哈哈哈~<br />
更重要的一点：解构语法还适用于其他类型的变量进行互换。所以，用解构可以很easy地进行互换。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    [a, b] = [b, a];
    <span class="hljs-keyword">return</span> [a, b];
}
<span class="hljs-built_in">console</span>.log(exchange(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)); <span class="hljs-comment">//[6, 3]</span>
</code></div></pre>
<h3><a id="异或操作"></a>异或操作</h3>
<p>巧用位运算的技巧，利用 a ^ b ^ b == a 的特点，进行数值交换，避免了使用算术运算带来的弊端，不会发生溢出问题。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    a ^= b;
    b ^= a;
    a ^= b;
    <span class="hljs-keyword">return</span> [a, b];
}
</code></div></pre>
<p>或者</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">a, b</span>) </span>{
    a = (b = (a ^= b) ^ b) ^ a;
    <span class="hljs-keyword">return</span> [a, b];
}
</code></div></pre>
<h2><a id="排序"></a>排序</h2>
<h2><a id="删除、去重"></a>删除、去重</h2>
<h3><a id="正序去重复"></a>正序去重复</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distinct</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
        <span class="hljs-comment">//如果有相同的值,不同的索引,删除当前数据</span>
        <span class="hljs-keyword">if</span> (list.indexOf(list[i]) != i) {
            list.splice(i, <span class="hljs-number">1</span>);
            i--; <span class="hljs-comment">//删除后索引回退</span>
        }
    }
    <span class="hljs-keyword">return</span> list;
}

<span class="hljs-built_in">console</span>.log(distinct(list)); <span class="hljs-comment">//[ 2, 1, 3, 45, 5, 4 ]</span>
</code></div></pre>
<h3><a id="倒序去重复"></a>倒序去重复</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distinct</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = list.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-comment">//如果有相同的值,不同的索引,删除当前数据</span>
        <span class="hljs-keyword">if</span> (list.indexOf(list[i]) != i) {
            list.splice(i, <span class="hljs-number">1</span>);
        }
    }
    <span class="hljs-keyword">return</span> list;
}

<span class="hljs-built_in">console</span>.log(distinct(list)); <span class="hljs-comment">//[ 2, 1, 3, 45, 5, 4 ]</span>
</code></div></pre>
<h2><a id="排序"></a>排序</h2>
<h3><a id="普通排序"></a>普通排序</h3>
<pre><div class="hljs"><code class="lang-js">list.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 正序</span>
list.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a); <span class="hljs-comment">// 倒序</span>
</code></div></pre>
<h3><a id="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br />
这个算法的名字由来, 是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br />
<img src="assets/array/1_bubble_sort.gif" alt="冒泡排序(Bubble Sort)" /></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
</div>
</body>
<script src="/js/prism.js"></script>
<script>
    window.onload = function() {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
    }
</script>

</html>