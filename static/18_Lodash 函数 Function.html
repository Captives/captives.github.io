<!DOCTYPE html>
<html>

</html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Lodash 函数 Function</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <!-- Bootstrap CSS-->
    <link rel="stylesheet" href="/vendor/bootstrap/css/bootstrap.min.css">
    <!-- theme stylesheet-->
    <link rel="stylesheet" href="/css/style.default.css" id="theme-stylesheet">
    <!-- code stylesheet-->
    <link rel="stylesheet" href="/css/page.css">
    <!-- Custom stylesheet-->
    <link rel="stylesheet" href="/css/custom.css">
    <!-- Favicon-->
    <link rel="shortcut icon" href="/img/favicon.png">
    <!-- Tweaks for older IEs-->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->
</head>

<body>
    <div id="all">
        <div class="container-fluid">
            <div class="row row-offcanvas row-offcanvas-left">
                <!--   *** SIDEBAR ***-->
<div id="sidebar" class="col-md-4 col-lg-3 sidebar-offcanvas">
    <div class="sidebar-content">
        <h1 class="sidebar-heading">
            <a href="/index.html">Creative</a>
        </h1>
        <p class="sidebar-p">I am a creative illustrator and graphic designer with more than 10 years of experience. </p>
        <p class="sidebar-p">Originally from Toronto, currently based in London. </p>
        <ul class="sidebar-menu">
            <li class="sidebar-item">
                <a href="/index.html" class="sidebar-link">首页</a>
            </li>
            <li class="sidebar-item">
                <a href="/article.html" class="sidebar-link">文章</a>
            </li>
            <li class="sidebar-item">
                <a href="/favorite.html" class="sidebar-link">收藏夹</a>
            </li>
            <li class="sidebar-item">
                <a href="/contact.html" class="sidebar-link">联系我</a>
            </li>
        </ul>
        <p class="social">
            <a href="#" data-animate-hover="pulse" class="external facebook">
                <i class="fa fa-facebook"></i>
            </a>
            <a href="#" data-animate-hover="pulse" class="external gplus">
                <i class="fa fa-google-plus"></i>
            </a>
            <a href="#" data-animate-hover="pulse" class="external twitter">
                <i class="fa fa-twitter"></i>
            </a>
            <a href="#" title="" class="external instagram">
                <i class="fa fa-instagram"></i>
            </a>
            <a href="#" data-animate-hover="pulse" class="email">
                <i class="fa fa-envelope"></i>
            </a>
        </p>
    </div>
</div>
<!--   *** SIDEBAR END ***  -->
                <!--*** DETAIL ***-->
                <div class="col-md-8 col-lg-9 content-column white-background">
                    <div class="small-navbar d-flex d-md-none">
    <button type="button" data-toggle="offcanvas" class="btn btn-outline-primary"> <i class="fa fa-align-left mr-2"></i>Menu</button>
    <h1 class="small-navbar-heading"> <a href="index.html">Creative </a></h1>
</div>
                    <div class="row">
                        <div class="col-xl-10">
                            <div class="content-column-content">
                                <h1><a id="Lodash 函数"></a>Lodash 函数</h1>
<h3><a id="_.before(n, func)"></a>_.before(n, func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>n (number): 超过多少次不再调用func（注：限制调用func 的次数）。</li>
<li>func (Function): 限制执行的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的限定函数。</li>
</ul>
</details></div><p>创建一个调用<code>func</code>的函数，通过<code>this</code>绑定和创建函数的参数调用<code>func</code>，调用次数不超过 n 次。<br />
之后再调用这个函数，将返回最后一次调用<code>func</code>的结果。</p>
<pre><code class="lang-js">jQuery(element).on('click', _.before(5, addContactToList));
// =&gt; 允许将最多4个联系人添加到列表中
</code></pre>
<h3><a id="_.after(n, func)"></a>_.after(n, func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>n (number): func 方法应该在调用多少次后才执行。</li>
<li>func (Function): 用来限定的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的限定函数。</li>
</ul>
</details></div><p><code>_.before</code>的反向函数;<br />
此方法创建一个函数，当他被调用至少<code>n</code>次时才会触发<code>func</code>。</p>
<pre><code class="lang-js">var saves = ['profile', 'settings'];
 
var done = _.after(saves.length, function() {
  console.log('done saving!');
});
 
_.forEach(saves, function(type) {
  asyncSave({ 'type': type, 'complete': done });
});
// =&gt; 两次异步日志保存完成后才会输出：'done saving!'
</code></pre>
<h3><a id="_.ary(func, [n = func.length])"></a>_.ary(func, [n = func.length])</h3>
<div class='more-block'><details><summary>参数：</summary>
<ul>
<li>func (Function): 需要被限制参数个数的函数。</li>
<li>[n=func.length] (number): 限制的参数数量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>(Function): 返回新的覆盖函数。</li>
</ul>
</details></div><p>创建一个调用<code>func</code>的函数。调用<code>func</code>时最多接受<code>n</code>个参数，忽略多出的参数。</p>
<pre><code class="lang-js">_.map(['6', '8', '10'], _.ary(parseInt, 1));
// =&gt; [6, 8, 10]
</code></pre>
<p>等价于</p>
<pre><code class="lang-js">_.map(['6', '8', '10'], _.ary((a, b) =&gt; {
    console.log(a, b);
    return parseInt(a);
}, 1));
/**
 6 undefined
 8 undefined
 10 undefined 
=&gt; [6, 8, 10]
*/
</code></pre>
<p>扩展<mark>n = 2</mark>时，将输出：</p>
<pre><code class="lang-js"> 6 0
 8 1
 10 2
=&gt; [6, 8, 10]
</code></pre>
<h3><a id="_.bind(func, thisArg, [partials])"></a>_.bind(func, thisArg, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 绑定的函数。</li>
<li>thisArg (*): func 绑定的this对象。</li>
<li>[partials] (…*): 附加的部分参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的绑定函数。</li>
</ul>
</details></div><p>创建一个调用<code>func</code>的函数，<code>thisArg</code>绑定<code>func</code>函数中的<code>this</code>(注：this的上下文为thisArg)，并且<code>func</code>函数会接收<code>partials</code>附加参数。</p>
<p>_.bind.placeholder 值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>不同于原生的 Function#bind，这个方法不会设置绑定函数的 <code>length</code> 属性。</p>
</div><pre><code class="lang-js">var greet = function(greeting, punctuation) {
  return greeting + ' ' + this.user + punctuation;
};
 
var object = { 'user': 'fred' };
 
var bound = _.bind(greet, object, 'hi');
bound('!');
// =&gt; 'hi fred!'
 
// 占位符绑定
var bound = _.bind(greet, object, _, '!');
bound('hi');
// =&gt; 'hi fred!'
</code></pre>
<h3><a id="_.bindKey(object, key, [partials])"></a>_.bindKey(object, key, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>object (Object): 需要绑定函数的对象。</li>
<li>key (string): 需要绑定函数对象的键。</li>
<li>[partials] (…*): 附加的部分参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的绑定函数。</li>
</ul>
</details></div><p>创建一个函数,在<code>object[key]</code>上通过接收<code>partials</code>附加参数，调用这个方法。<br />
这个方法与<code>_.bind</code>的不同之处在于允许重新定义绑定函数即使它还不存在。</p>
<p>_.bind.placeholder值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block info'><p>浏览<a href="http://peter.michaux.ca/articles/lazy-function-definition-pattern" target="_blank">Peter Michaux’s article</a>了解更多详情。</p>
</div><pre><code class="lang-js">var object = {
  'user': 'fred',
  'greet': function(greeting, punctuation) {
    return greeting + ' ' + this.user + punctuation;
  }
};
 
var bound = _.bindKey(object, 'greet', 'hi');
bound('!');
// =&gt; 'hi fred!'
 
object.greet = function(greeting, punctuation) {
  return greeting + 'ya ' + this.user + punctuation;
};
 
bound('!');
// =&gt; 'hiya fred!'
 
// 占位符绑定
var bound = _.bindKey(object, 'greet', _, '!');
bound('hi');
// =&gt; 'hiya fred!'
</code></pre>
<h3><a id="_.partial(func, [partials])"></a>_.partial(func, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 需要预设的函数</li>
<li>[partials] (…*): 预设的参数</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回预设参数的函数。</li>
</ul>
</details></div><p>创建一个函数。 该函数调用<code>func</code>，并传入预设的<code>partials</code>参数。 这个方法类似<code>_.bind</code>，除了它不会绑定 <code>this</code>。</p>
<p>这个 _.partial.placeholder 的值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置 “length” 到函数上。</p>
</div><pre><code class="lang-js">var greet = function(greeting, name) {
  return greeting + ' ' + name;
};
 
var sayHelloTo = _.partial(greet, 'hello');
sayHelloTo('fred');
// =&gt; 'hello fred'
 
// 使用了占位符。
var greetFred = _.partial(greet, _, 'fred');
greetFred('hi');
// =&gt; 'hi fred'
</code></pre>
<h3><a id="_.partialRight(func, [partials])"></a>_.partialRight(func, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 需要预设的函数</li>
<li>[partials] (…*): 预设的参数</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回预设参数的函数。</li>
</ul>
</details></div><p>这个函数类似<code>_.partial</code>，除了预设参数被附加到接受参数的后面。</p>
<p>这个_.partialRight.placeholder 的值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置 “length” 到函数上。</p>
</div><pre><code class="lang-js">var greet = function(greeting, name) {
  return greeting + ' ' + name;
};
 
var greetFred = _.partialRight(greet, 'fred');
greetFred('hi');
// =&gt; 'hi fred'
 
// 使用了占位符。
var sayHelloTo = _.partialRight(greet, 'hello', _);
sayHelloTo('fred');
// =&gt; 'hello fred'
</code></pre>
<h3><a id="_.curry(func, [arity = func.length])"></a>_.curry(func, [arity = func.length])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 用来柯里化（curry）的函数。</li>
<li>[arity=func.length] (number): 需要提供给 func 的参数数量。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的柯里化（curry）函数。</li>
</ul>
</details></div><p>创建一个函数，该函数接收<code>func</code>的参数，要么调用func返回的结果，如果 func 所需参数已经提供，则直接返回 func 所执行的结果。或返回一个函数，接受余下的func 参数的函数，可以使用 func.length 强制需要累积的参数个数。</p>
<p>_.curry.placeholder 值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置<code>curried</code>函数的<code>length</code>属性。</p>
</div><pre><code class="lang-js">var abc = function(a, b, c) {
  return [a, b, c];
};
 
var curried = _.curry(abc);
 
curried(1)(2)(3);
// =&gt; [1, 2, 3]
 
curried(1, 2)(3);
// =&gt; [1, 2, 3]
 
curried(1, 2, 3);
// =&gt; [1, 2, 3]
 
// Curried with placeholders.
curried(1)(_, 3)(2);
// =&gt; [1, 2, 3]
</code></pre>
<h3><a id="_.curryRight(func, [arity = func.length])"></a>_.curryRight(func, [arity = func.length])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 用来柯里化（curry）的函数。</li>
<li>[arity=func.length] (number): 需要提供给 func 的参数数量。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的柯里化（curry）函数。</li>
</ul>
</details></div><p>这个方法类似<code>_.curry</code>。 除了它接受参数的方式用<code>_.partialRight</code>代替<code>_.partial</code>。</p>
<p>_.curryRight.placeholder值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置 curried 函数的 “length” 属性。</p>
</div><pre><code class="lang-js">var abc = function(a, b, c) {
  return [a, b, c];
};
 
var curried = _.curryRight(abc);
 
curried(3)(2)(1);
// =&gt; [1, 2, 3]
 
curried(2, 3)(1);
// =&gt; [1, 2, 3]
 
curried(1, 2, 3);
// =&gt; [1, 2, 3]
 
// Curried with placeholders.
curried(3)(1, _)(2);
// =&gt; [1, 2, 3]
</code></pre>
<h3><a id="_.rearg(func, indexes)"></a>_.rearg(func, indexes)</h3>
<div class='more-block'><details><summary>参数</summary>
<p>func (Function): 待调用的函数。<br />
indexes (…(number|number[])): 排列参数的位置。<br />
返回<br />
(Function): 返回新的函数。</p>
</details></div><p>创建一个函数,调用<code>func</code>时，根据指定的<code>indexes</code>调整对应位置参数。其中第一个索引值是对应第一个参数，第二个索引值是作为第二个参数，依此类推。</p>
<pre><code class="lang-js">var rearged = _.rearg(function(a, b, c) {
  return [a, b, c];
}, [2, 0, 1]);
 
rearged('b', 'c', 'a')
// =&gt; ['a', 'b', 'c']
</code></pre>
<h3><a id="_.rest(func, [start=func.length-1])"></a>_.rest(func, [start=func.length-1])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要应用的函数。</li>
<li>[start=func.length-1] (number): rest 参数的开始位置。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数，调用<code>func</code>时，<code>this</code>绑定到创建的新函数，并且<code>start</code>之后的参数作为数组传入。</p>
<pre><code class="lang-js">var say = _.rest(function(what, names) {
  return what + ' ' + _.initial(names).join(', ') +
    (_.size(names) &gt; 1 ? ', &amp; ' : '') + _.last(names);
});
 
say('hello', 'fred', 'barney', 'pebbles');
// =&gt; 'hello fred, barney, &amp; pebbles'
</code></pre>
<h3><a id="_.spread(func, [start=0])"></a>_.spread(func, [start=0])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要应用传播参数的函数。</li>
<li>[start=0] (number): spread 参数的开始位置.</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数，调用<code>func</code>时，<code>this</code>绑定到创建的新函数，把参数作为数组传入，类似于<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply" target="_blank">Function#apply</a>.</p>
<pre><code class="lang-js">var say = _.spread(function(who, what) {
  return who + ' says ' + what;
});
 
say(['fred', 'hello']);
// =&gt; 'fred says hello'
 
var numbers = Promise.all([
  Promise.resolve(40),
  Promise.resolve(36)
]);
 
numbers.then(_.spread(function(x, y) {
  return x + y;
}));
// =&gt; a Promise of 76
</code></pre>
<h3><a id="_.throttle(func, [wait = 0], [options = ])"></a>_.throttle(func, [wait = 0], [options = ])</h3>
<div class='more-block'><details><summary>参数</summary>
<p>func (Function): 要节流的函数。<br />
[wait=0] (number): 需要节流的毫秒。<br />
[options=] (Object): 选项对象。<br />
[options.leading=true] (boolean): 指定调用在节流开始前。<br />
[options.trailing=true] (boolean): 指定调用在节流结束后。<br />
返回<br />
(Function): 返回节流的函数。</p>
</details></div><p>创建一个节流函数，在<code>wait</code>毫秒内最多执行<code>func</code>一次的函数。 该函数提供一个<code>cancel</code>方法取消延迟的函数调用以及 <code>flush</code>方法立即调用。 可以提供一个<code>options</code>对象决定如何调用<code>func</code>方法，<code>options.leading</code>与<code>|</code>或 <code>options.trailing</code>决定<code>wait</code>前后如何触发。<code>func</code>会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次<code>func</code>调用的结果。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>如果<code>leading</code>和<code>trailing</code>都设定为<mark>true</mark>则<code>func</code>允许<code>trailing</code>方式调用的条件为: 在<code>wait</code>期间多次调用。</p>
</div><p>如果<code>wait</code>为<mark>0</mark>并且<code>leading</code>为<mark>false</mark>,<code>func</code>调用将被推迟到下一个点，类似<code>setTimeout</code>为<mark>0</mark>的超时。</p>
<div class='tip-block info'><p>查看 <a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank">David Corbacho’s article</a> 了解<a href="https://www.lodashjs.com/docs/lodash.debounce" target="_blank">_.throttle</a>与<a href="https://www.lodashjs.com/docs/lodash.throttle" target="_blank">_.debounce</a>的区别。</p>
</div><pre><code class="lang-js">// 避免在滚动时过分的更新定位
jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 
// 点击后就调用 `renewToken`，但5分钟内超过1次。
var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
jQuery(element).on('click', throttled);
 
// 取消一个 trailing 的节流调用。
jQuery(window).on('popstate', throttled.cancel);
</code></pre>
<h3><a id="_.unary(func)"></a>_.unary(func)</h3>
<p>创建一个最多接受一个参数的函数，忽略多余的参数。</p>
<pre><code class="lang-js">_.map(['6', '8', '10'], _.unary(parseInt));
// =&gt; [6, 8, 10]
</code></pre>
<h3><a id="_.wrap(value, [wrapper=identity])"></a>_.wrap(value, [wrapper=identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>value (*): 要包装的值。</li>
<li>[wrapper=identity] (Function): 包装函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数。提供的<code>value</code>包装在<code>wrapper</code>函数的第一个参数里。 任何附加的参数都提供给<code>wrapper</code>函数。 被调用时<code>this</code>绑定在创建的函数上。</p>
<pre><code class="lang-js">var p = _.wrap(_.escape, function(func, text) {
  return '&lt;p&gt;' + func(text) + '&lt;/p&gt;';
});
 
p('fred, barney, &amp; pebbles');
// =&gt; '&lt;p&gt;fred, barney, &amp; pebbles&lt;/p&gt;'
</code></pre>
<h2><a id="延迟"></a>延迟</h2>
<h3><a id="_.debounce(func, [wait = 0], [options = ])"></a>_.debounce(func, [wait = 0], [options = ])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要防抖动的函数。</li>
<li>[wait=0] (number): 需要延迟的毫秒数。</li>
<li>[options=] (Object): 选项对象。</li>
<li>[options.leading=false] (boolean): 指定在延迟开始前调用。</li>
<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>
<li>[options.trailing=true] (boolean): 指定在延迟结束后调用。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的 debounced（防抖动）函数。</li>
</ul>
</details></div><p>创建一个<code>debounced</code>（防抖动）函数，该函数会从上一次被调用后，延迟<code>wait</code>毫秒后调用<code>func</code>方法。<code>debounced</code>（防抖动）函数提供一个<code>cancel</code>方法取消延迟的函数调用以及<code>flush</code>方法立即调用。 可以提供一个 <code>options</code>（选项）对象决定如何调用<code>func</code>方法，<code>options.leading</code> 与<code>|</code> 或<code>options.trailing</code>决定延迟前后如何触发（注：是 <mark>先调用后等待</mark>还是 <mark>先等待后调用</mark>）。 <code>func</code>调用时会传入最后一次提供给<code>debounced</code>（防抖动）函数的参数。 后续调用的<code>debounced</code>（防抖动）函数返回是最后一次<code>func</code>调用的结果。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>如果<code>leading</code>和<code>trailing</code>选项为<mark>true</mark>, 则<code>func</code>允许<code>trailing</code>方式调用的条件为: 在<code>wait</code>期间多次调用防抖方法。</p>
<p>如果<code>wait</code>为<mark>0</mark> 并且<code>leading</code>为<mark>false</mark>, <code>func</code>调用将被推迟到下一个点，类似<code>setTimeout</code>为<mark>0</mark>的超时。</p>
</div><pre><code class="lang-js">// 避免窗口在变动时出现昂贵的计算开销。
jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 
// 当点击时 `sendMail` 随后就被调用。
jQuery(element).on('click', _.debounce(sendMail, 300, {
  'leading': true,
  'trailing': false
}));
 
// 确保 `batchLog` 调用1次之后，1秒内会被触发。
var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
var source = new EventSource('/stream');
jQuery(source).on('message', debounced);
 
// 取消一个 trailing 的防抖动调用
jQuery(window).on('popstate', debounced.cancel);
</code></pre>
<h3><a id="_.defer(func, [args])"></a>_.defer(func, [args])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要延迟的函数。</li>
<li>[args] (…*): 会在调用时传给 func 的参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(number):返回计时器 id。</li>
</ul>
</details></div><p>推迟调用<code>func</code>，直到当前堆栈清理完毕。 调用时，任何附加的参数会传给<code>func</code>。</p>
<pre><code class="lang-js">_.defer(function(text) {
  console.log(text);
}, 'deferred');
// =&gt; 一毫秒或更久一些输出 'deferred'。
</code></pre>
<h3><a id="_.delay(func, wait, [args])"></a>_.delay(func, wait, [args])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要延迟的函数。</li>
<li>wait (number): 要延迟的毫秒数。</li>
<li>[args] (…*): 会在调用时传入到 func 的参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(number): 返回计时器 id</li>
</ul>
</details></div><p>延迟<code>wait</code>毫秒后调用<code>func</code>。 调用时，任何附加的参数会传给<code>func</code>。</p>
<pre><code class="lang-js">_.delay(function(text) {
  console.log(text);
}, 1000, 'later');
// =&gt; 一秒后输出 'later'。
</code></pre>
<h2><a id="转换"></a>转换</h2>
<h3><a id="_.flip(func)"></a>_.flip(func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要翻转参数的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数，调用<code>func</code>时候接收翻转的参数。</p>
<pre><code class="lang-js">var flipped = _.flip(function() {
  return _.toArray(arguments);
});
 
flipped('a', 'b', 'c', 'd');
// =&gt; ['d', 'c', 'b', 'a']
</code></pre>
<h3><a id="_.memoize(func, [resolver])"></a>_.memoize(func, [resolver])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 需要缓存化的函数.</li>
<li>[resolver] (Function): 这个函数的返回值作为缓存的 key。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回缓存化后的函数。</li>
</ul>
</details></div><p>创建一个会缓存<code>func</code>结果的函数。 如果提供了<code>resolver</code>，就用<code>resolver</code>的返回值作为<code>key</code>缓存函数的结果。 默认情况下用第一个参数作为缓存的<code>key</code>。 <code>func</code>在调用时<code>this</code>会绑定在缓存函数上。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>缓存会暴露在缓存函数的<code>cache</code>上。 它是可以定制的，只要替换了<code>_.memoize.Cache</code>构造函数，或实现了Map的 <code>delete</code>, <code>get</code>, <code>has</code>, 和<code>set</code>方法。</p>
</div><pre><code class="lang-js">var object = { 'a': 1, 'b': 2 };
var other = { 'c': 3, 'd': 4 };
 
var values = _.memoize(_.values);
values(object);
// =&gt; [1, 2]
 
values(other);
// =&gt; [3, 4]
 
object.a = 2;
values(object);
// =&gt; [1, 2]
 
// 修改结果缓存。
values.cache.set(object, ['a', 'b']);
values(object);
// =&gt; ['a', 'b']
 
// 替换 `_.memoize.Cache`。
_.memoize.Cache = WeakMap;
</code></pre>
<h3><a id="_.negate(predicate:Function)"></a>_.negate(predicate:Function)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>predicate (Function): 需要对结果取反的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回一个新的取反函数。</li>
</ul>
</details></div><p>创建一个针对断言函数<code>func</code>结果取反的函数。 <code>func</code>断言函数被调用的时候, <code>this</code>绑定到创建的函数，并传入对应参数。</p>
<pre><code class="lang-js">function isEven(n) {
  return n % 2 == 0;
}
 
_.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
// =&gt; [1, 3, 5]
</code></pre>
<h3><a id="_.once(func)"></a>_.once(func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 指定的触发的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的受限函数。</li>
</ul>
</details></div><p>创建一个只能调用<code>func</code>一次的函数。重复调用返回第一次调用的结果。<code>func</code>调用时，<code>this</code>绑定到创建的函数，并传入对应参数。</p>
<pre><code class="lang-js">var initialize = _.once(createApplication);
initializ	e();
initialize();
// `initialize` 只能调用 `createApplication` 一次。
</code></pre>
<h3><a id="_.overArgs(func, [transforms = [ _.identity ]])"></a>_.overArgs(func, [transforms = [ _.identity ]])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function):要包裹的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新函数。</li>
</ul>
</details></div><p>创建一个函数，调用func时参数为相对应的<code>transforms</code>的返回值。</p>
<div class='tip-block info'><p>执行func函数之前，需要通过<code>transforms</code> 处理参数；</p>
</div><pre><code class="lang-js">function doubled(n) {
  return n * 2;
}
 
function square(n) {
  return n * n;
}
 
var func = _.overArgs(function(x, y) {
  return [x, y];
}, [square, doubled]);
 
func(9, 3);
// =&gt; [81, 6]
 
func(10, 5);
// =&gt; [100, 10]
</code></pre>
<p>或</p>
<pre><code class="lang-js">var func = _.overArgs(function(x, y) {
  return x + y;
}, [square, doubled]);

func(9, 3);
// =&gt; 87
</code></pre>

                            </div>
                             <div class="content-column-content">
                                <div>上一个：
                                    <a href="/static/17_Lodash 对象 Map.html"> Lodash 对象 Map</a>
                                </div>
                                <div>
                                下一个：
                                    <a href="/static/19_Lodash 实用函数 Utils.html"> Lodash 实用函数 Utils</a>
                                </div>
                             </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- JavaScript files-->
    <script src="/vendor/jquery/jquery.min.js"></script>
    <script src="/vendor/popper.js/umd/popper.min.js"></script>
    <script src="/vendor/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/prism.js"></script>
    <script>
        window.onload = function() {
            window.Prism = window.Prism || {};
            window.Prism.manual = true;
        }
    </script>
    <script>
    // ------------------------------------------------------ //
    // Main slider
    // ------------------------------------------------------ //
    // $('#main-slider').owlCarousel({
    //     items: 1,
    //     nav: false,
    //     dots: true,
    //     autoplay: true,
    //     autoplayHoverPause: true
    // });
    </script>
    <script src="/js/front.js "></script>
</body>