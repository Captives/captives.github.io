<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/code-style.css">
    <link rel="stylesheet" href="/css/page.css">
    <title>Lodash 函数</title>
</head>

<body>
    <div class="content"><h1><a id="Lodash 函数"></a>Lodash 函数</h1>
<h3><a id="_.before(n, func)"></a>_.before(n, func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>n (number): 超过多少次不再调用func（注：限制调用func 的次数）。</li>
<li>func (Function): 限制执行的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的限定函数。</li>
</ul>
</details></div><p>创建一个调用<code>func</code>的函数，通过<code>this</code>绑定和创建函数的参数调用<code>func</code>，调用次数不超过 n 次。<br />
之后再调用这个函数，将返回最后一次调用<code>func</code>的结果。</p>
<pre><div class="hljs"><code class="lang-js">jQuery(element).on(<span class="hljs-string">'click'</span>, _.before(<span class="hljs-number">5</span>, addContactToList));
<span class="hljs-comment">// =&gt; 允许将最多4个联系人添加到列表中</span>
</code></div></pre>
<h3><a id="_.after(n, func)"></a>_.after(n, func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>n (number): func 方法应该在调用多少次后才执行。</li>
<li>func (Function): 用来限定的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的限定函数。</li>
</ul>
</details></div><p><code>_.before</code>的反向函数;<br />
此方法创建一个函数，当他被调用至少<code>n</code>次时才会触发<code>func</code>。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> saves = [<span class="hljs-string">'profile'</span>, <span class="hljs-string">'settings'</span>];
 
<span class="hljs-keyword">var</span> done = _.after(saves.length, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done saving!'</span>);
});
 
_.forEach(saves, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>{
  asyncSave({ <span class="hljs-string">'type'</span>: type, <span class="hljs-string">'complete'</span>: done });
});
<span class="hljs-comment">// =&gt; 两次异步日志保存完成后才会输出：'done saving!'</span>
</code></div></pre>
<h3><a id="_.ary(func, [n = func.length])"></a>_.ary(func, [n = func.length])</h3>
<div class='more-block'><details><summary>参数：</summary>
<ul>
<li>func (Function): 需要被限制参数个数的函数。</li>
<li>[n=func.length] (number): 限制的参数数量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>(Function): 返回新的覆盖函数。</li>
</ul>
</details></div><p>创建一个调用<code>func</code>的函数。调用<code>func</code>时最多接受<code>n</code>个参数，忽略多出的参数。</p>
<pre><div class="hljs"><code class="lang-js">_.map([<span class="hljs-string">'6'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>], _.ary(<span class="hljs-built_in">parseInt</span>, <span class="hljs-number">1</span>));
<span class="hljs-comment">// =&gt; [6, 8, 10]</span>
</code></div></pre>
<p>等价于</p>
<pre><div class="hljs"><code class="lang-js">_.map([<span class="hljs-string">'6'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>], _.ary(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(a, b);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(a);
}, <span class="hljs-number">1</span>));
<span class="hljs-comment">/**
 6 undefined
 8 undefined
 10 undefined 
=&gt; [6, 8, 10]
*/</span>
</code></div></pre>
<p>扩展<mark>n = 2</mark>时，将输出：</p>
<pre><div class="hljs"><code class="lang-js"> <span class="hljs-number">6</span> <span class="hljs-number">0</span>
 <span class="hljs-number">8</span> <span class="hljs-number">1</span>
 <span class="hljs-number">10</span> <span class="hljs-number">2</span>
=&gt; [<span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]
</code></div></pre>
<h3><a id="_.bind(func, thisArg, [partials])"></a>_.bind(func, thisArg, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 绑定的函数。</li>
<li>thisArg (*): func 绑定的this对象。</li>
<li>[partials] (…*): 附加的部分参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的绑定函数。</li>
</ul>
</details></div><p>创建一个调用<code>func</code>的函数，<code>thisArg</code>绑定<code>func</code>函数中的<code>this</code>(注：this的上下文为thisArg)，并且<code>func</code>函数会接收<code>partials</code>附加参数。</p>
<p>_.bind.placeholder 值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>不同于原生的 Function#bind，这个方法不会设置绑定函数的 <code>length</code> 属性。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">greeting, punctuation</span>) </span>{
  <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.user + punctuation;
};
 
<span class="hljs-keyword">var</span> object = { <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span> };
 
<span class="hljs-keyword">var</span> bound = _.bind(greet, object, <span class="hljs-string">'hi'</span>);
bound(<span class="hljs-string">'!'</span>);
<span class="hljs-comment">// =&gt; 'hi fred!'</span>
 
<span class="hljs-comment">// 占位符绑定</span>
<span class="hljs-keyword">var</span> bound = _.bind(greet, object, _, <span class="hljs-string">'!'</span>);
bound(<span class="hljs-string">'hi'</span>);
<span class="hljs-comment">// =&gt; 'hi fred!'</span>
</code></div></pre>
<h3><a id="_.bindKey(object, key, [partials])"></a>_.bindKey(object, key, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>object (Object): 需要绑定函数的对象。</li>
<li>key (string): 需要绑定函数对象的键。</li>
<li>[partials] (…*): 附加的部分参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的绑定函数。</li>
</ul>
</details></div><p>创建一个函数,在<code>object[key]</code>上通过接收<code>partials</code>附加参数，调用这个方法。<br />
这个方法与<code>_.bind</code>的不同之处在于允许重新定义绑定函数即使它还不存在。</p>
<p>_.bind.placeholder值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block info'><p>浏览<a href="http://peter.michaux.ca/articles/lazy-function-definition-pattern" target="_blank">Peter Michaux’s article</a>了解更多详情。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> object = {
  <span class="hljs-string">'user'</span>: <span class="hljs-string">'fred'</span>,
  <span class="hljs-string">'greet'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">greeting, punctuation</span>) </span>{
    <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.user + punctuation;
  }
};
 
<span class="hljs-keyword">var</span> bound = _.bindKey(object, <span class="hljs-string">'greet'</span>, <span class="hljs-string">'hi'</span>);
bound(<span class="hljs-string">'!'</span>);
<span class="hljs-comment">// =&gt; 'hi fred!'</span>
 
object.greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">greeting, punctuation</span>) </span>{
  <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">'ya '</span> + <span class="hljs-keyword">this</span>.user + punctuation;
};
 
bound(<span class="hljs-string">'!'</span>);
<span class="hljs-comment">// =&gt; 'hiya fred!'</span>
 
<span class="hljs-comment">// 占位符绑定</span>
<span class="hljs-keyword">var</span> bound = _.bindKey(object, <span class="hljs-string">'greet'</span>, _, <span class="hljs-string">'!'</span>);
bound(<span class="hljs-string">'hi'</span>);
<span class="hljs-comment">// =&gt; 'hiya fred!'</span>
</code></div></pre>
<h3><a id="_.partial(func, [partials])"></a>_.partial(func, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 需要预设的函数</li>
<li>[partials] (…*): 预设的参数</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回预设参数的函数。</li>
</ul>
</details></div><p>创建一个函数。 该函数调用<code>func</code>，并传入预设的<code>partials</code>参数。 这个方法类似<code>_.bind</code>，除了它不会绑定 <code>this</code>。</p>
<p>这个 _.partial.placeholder 的值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置 “length” 到函数上。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">greeting, name</span>) </span>{
  <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">' '</span> + name;
};
 
<span class="hljs-keyword">var</span> sayHelloTo = _.partial(greet, <span class="hljs-string">'hello'</span>);
sayHelloTo(<span class="hljs-string">'fred'</span>);
<span class="hljs-comment">// =&gt; 'hello fred'</span>
 
<span class="hljs-comment">// 使用了占位符。</span>
<span class="hljs-keyword">var</span> greetFred = _.partial(greet, _, <span class="hljs-string">'fred'</span>);
greetFred(<span class="hljs-string">'hi'</span>);
<span class="hljs-comment">// =&gt; 'hi fred'</span>
</code></div></pre>
<h3><a id="_.partialRight(func, [partials])"></a>_.partialRight(func, [partials])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 需要预设的函数</li>
<li>[partials] (…*): 预设的参数</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回预设参数的函数。</li>
</ul>
</details></div><p>这个函数类似<code>_.partial</code>，除了预设参数被附加到接受参数的后面。</p>
<p>这个_.partialRight.placeholder 的值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置 “length” 到函数上。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">greeting, name</span>) </span>{
  <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">' '</span> + name;
};
 
<span class="hljs-keyword">var</span> greetFred = _.partialRight(greet, <span class="hljs-string">'fred'</span>);
greetFred(<span class="hljs-string">'hi'</span>);
<span class="hljs-comment">// =&gt; 'hi fred'</span>
 
<span class="hljs-comment">// 使用了占位符。</span>
<span class="hljs-keyword">var</span> sayHelloTo = _.partialRight(greet, <span class="hljs-string">'hello'</span>, _);
sayHelloTo(<span class="hljs-string">'fred'</span>);
<span class="hljs-comment">// =&gt; 'hello fred'</span>
</code></div></pre>
<h3><a id="_.curry(func, [arity = func.length])"></a>_.curry(func, [arity = func.length])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 用来柯里化（curry）的函数。</li>
<li>[arity=func.length] (number): 需要提供给 func 的参数数量。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的柯里化（curry）函数。</li>
</ul>
</details></div><p>创建一个函数，该函数接收<code>func</code>的参数，要么调用func返回的结果，如果 func 所需参数已经提供，则直接返回 func 所执行的结果。或返回一个函数，接受余下的func 参数的函数，可以使用 func.length 强制需要累积的参数个数。</p>
<p>_.curry.placeholder 值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置<code>curried</code>函数的<code>length</code>属性。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> abc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>{
  <span class="hljs-keyword">return</span> [a, b, c];
};
 
<span class="hljs-keyword">var</span> curried = _.curry(abc);
 
curried(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
 
curried(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
 
curried(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
 
<span class="hljs-comment">// Curried with placeholders.</span>
curried(<span class="hljs-number">1</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
</code></div></pre>
<h3><a id="_.curryRight(func, [arity = func.length])"></a>_.curryRight(func, [arity = func.length])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 用来柯里化（curry）的函数。</li>
<li>[arity=func.length] (number): 需要提供给 func 的参数数量。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的柯里化（curry）函数。</li>
</ul>
</details></div><p>这个方法类似<code>_.curry</code>。 除了它接受参数的方式用<code>_.partialRight</code>代替<code>_.partial</code>。</p>
<p>_.curryRight.placeholder值，默认是以<code>_</code>作为附加部分参数的占位符。</p>
<div class='tip-block warning'><p>这个方法不会设置 curried 函数的 “length” 属性。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> abc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>{
  <span class="hljs-keyword">return</span> [a, b, c];
};
 
<span class="hljs-keyword">var</span> curried = _.curryRight(abc);
 
curried(<span class="hljs-number">3</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">1</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
 
curried(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">1</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
 
curried(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
 
<span class="hljs-comment">// Curried with placeholders.</span>
curried(<span class="hljs-number">3</span>)(<span class="hljs-number">1</span>, _)(<span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>
</code></div></pre>
<h3><a id="_.rearg(func, indexes)"></a>_.rearg(func, indexes)</h3>
<div class='more-block'><details><summary>参数</summary>
<p>func (Function): 待调用的函数。<br />
indexes (…(number|number[])): 排列参数的位置。<br />
返回<br />
(Function): 返回新的函数。</p>
</details></div><p>创建一个函数,调用<code>func</code>时，根据指定的<code>indexes</code>调整对应位置参数。其中第一个索引值是对应第一个参数，第二个索引值是作为第二个参数，依此类推。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> rearged = _.rearg(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>{
  <span class="hljs-keyword">return</span> [a, b, c];
}, [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]);
 
rearged(<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>)
<span class="hljs-comment">// =&gt; ['a', 'b', 'c']</span>
</code></div></pre>
<h3><a id="_.rest(func, [start=func.length-1])"></a>_.rest(func, [start=func.length-1])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要应用的函数。</li>
<li>[start=func.length-1] (number): rest 参数的开始位置。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数，调用<code>func</code>时，<code>this</code>绑定到创建的新函数，并且<code>start</code>之后的参数作为数组传入。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> say = _.rest(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what, names</span>) </span>{
  <span class="hljs-keyword">return</span> what + <span class="hljs-string">' '</span> + _.initial(names).join(<span class="hljs-string">', '</span>) +
    (_.size(names) &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">', &amp; '</span> : <span class="hljs-string">''</span>) + _.last(names);
});
 
say(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'fred'</span>, <span class="hljs-string">'barney'</span>, <span class="hljs-string">'pebbles'</span>);
<span class="hljs-comment">// =&gt; 'hello fred, barney, &amp; pebbles'</span>
</code></div></pre>
<h3><a id="_.spread(func, [start=0])"></a>_.spread(func, [start=0])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要应用传播参数的函数。</li>
<li>[start=0] (number): spread 参数的开始位置.</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数，调用<code>func</code>时，<code>this</code>绑定到创建的新函数，把参数作为数组传入，类似于<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply" target="_blank">Function#apply</a>.</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> say = _.spread(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">who, what</span>) </span>{
  <span class="hljs-keyword">return</span> who + <span class="hljs-string">' says '</span> + what;
});
 
say([<span class="hljs-string">'fred'</span>, <span class="hljs-string">'hello'</span>]);
<span class="hljs-comment">// =&gt; 'fred says hello'</span>
 
<span class="hljs-keyword">var</span> numbers = <span class="hljs-built_in">Promise</span>.all([
  <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">40</span>),
  <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">36</span>)
]);
 
numbers.then(_.spread(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> x + y;
}));
<span class="hljs-comment">// =&gt; a Promise of 76</span>
</code></div></pre>
<h3><a id="_.throttle(func, [wait = 0], [options = ])"></a>_.throttle(func, [wait = 0], [options = ])</h3>
<div class='more-block'><details><summary>参数</summary>
<p>func (Function): 要节流的函数。<br />
[wait=0] (number): 需要节流的毫秒。<br />
[options=] (Object): 选项对象。<br />
[options.leading=true] (boolean): 指定调用在节流开始前。<br />
[options.trailing=true] (boolean): 指定调用在节流结束后。<br />
返回<br />
(Function): 返回节流的函数。</p>
</details></div><p>创建一个节流函数，在<code>wait</code>秒内最多执行<code>func</code>一次的函数。 该函数提供一个<code>cancel</code>方法取消延迟的函数调用以及 <code>flush</code>方法立即调用。 可以提供一个<code>options</code>对象决定如何调用<code>func</code>方法，<code>options.leading</code>与<code>|</code>或 <code>options.trailing</code>决定<code>wait</code>前后如何触发。<code>func</code>会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次<code>func</code>调用的结果。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>如果<code>leading</code>和<code>trailing</code>都设定为<mark>true</mark>则<code>func</code>允许<code>trailing</code>方式调用的条件为: 在<code>wait</code>期间多次调用。</p>
</div><p>如果<code>wait</code>为<mark>0</mark>并且<code>leading</code>为<mark>false</mark>,<code>func</code>调用将被推迟到下一个点，类似<code>setTimeout</code>为<mark>0</mark>的超时。</p>
<div class='tip-block info'><p>查看 <a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank">David Corbacho’s article</a> 了解<a href="https://www.lodashjs.com/docs/lodash.debounce" target="_blank">_.throttle</a>与<a href="https://www.lodashjs.com/docs/lodash.throttle" target="_blank">_.debounce</a>的区别。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-comment">// 避免在滚动时过分的更新定位</span>
jQuery(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'scroll'</span>, _.throttle(updatePosition, <span class="hljs-number">100</span>));
 
<span class="hljs-comment">// 点击后就调用 `renewToken`，但5分钟内超过1次。</span>
<span class="hljs-keyword">var</span> throttled = _.throttle(renewToken, <span class="hljs-number">300000</span>, { <span class="hljs-string">'trailing'</span>: <span class="hljs-literal">false</span> });
jQuery(element).on(<span class="hljs-string">'click'</span>, throttled);
 
<span class="hljs-comment">// 取消一个 trailing 的节流调用。</span>
jQuery(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'popstate'</span>, throttled.cancel);
</code></div></pre>
<h3><a id="_.unary(func)"></a>_.unary(func)</h3>
<p>创建一个最多接受一个参数的函数，忽略多余的参数。</p>
<pre><div class="hljs"><code class="lang-js">_.map([<span class="hljs-string">'6'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>], _.unary(<span class="hljs-built_in">parseInt</span>));
<span class="hljs-comment">// =&gt; [6, 8, 10]</span>
</code></div></pre>
<h3><a id="_.wrap(value, [wrapper=identity])"></a>_.wrap(value, [wrapper=identity])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>value (*): 要包装的值。</li>
<li>[wrapper=identity] (Function): 包装函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数。提供的<code>value</code>包装在<code>wrapper</code>函数的第一个参数里。 任何附加的参数都提供给<code>wrapper</code>函数。 被调用时<code>this</code>绑定在创建的函数上。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> p = _.wrap(_.escape, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, text</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;p&gt;'</span> + func(text) + <span class="hljs-string">'&lt;/p&gt;'</span>;
});
 
p(<span class="hljs-string">'fred, barney, &amp; pebbles'</span>);
<span class="hljs-comment">// =&gt; '&lt;p&gt;fred, barney, &amp; pebbles&lt;/p&gt;'</span>
</code></div></pre>
<h2><a id="延迟"></a>延迟</h2>
<h3><a id="_.debounce(func, [wait = 0], [options = ])"></a>_.debounce(func, [wait = 0], [options = ])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要防抖动的函数。</li>
<li>[wait=0] (number): 需要延迟的毫秒数。</li>
<li>[options=] (Object): 选项对象。</li>
<li>[options.leading=false] (boolean): 指定在延迟开始前调用。</li>
<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>
<li>[options.trailing=true] (boolean): 指定在延迟结束后调用。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的 debounced（防抖动）函数。</li>
</ul>
</details></div><p>创建一个<code>debounced</code>（防抖动）函数，该函数会从上一次被调用后，延迟<code>wait</code>毫秒后调用<code>func</code>方法。<code>debounced</code>（防抖动）函数提供一个<code>cancel</code>方法取消延迟的函数调用以及<code>flush</code>方法立即调用。 可以提供一个 <code>options</code>（选项）对象决定如何调用<code>func</code>方法，<code>options.leading</code> 与<code>|</code> 或<code>options.trailing</code>决定延迟前后如何触发（注：是 <mark>先调用后等待</mark>还是 <mark>先等待后调用</mark>）。 <code>func</code>调用时会传入最后一次提供给<code>debounced</code>（防抖动）函数的参数。 后续调用的<code>debounced</code>（防抖动）函数返回是最后一次<code>func</code>调用的结果。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>如果<code>leading</code>和<code>trailing</code>选项为<mark>true</mark>, 则<code>func</code>允许<code>trailing</code>方式调用的条件为: 在<code>wait</code>期间多次调用防抖方法。</p>
<p>如果<code>wait</code>为<mark>0</mark> 并且<code>leading</code>为<mark>false</mark>, <code>func</code>调用将被推迟到下一个点，类似<code>setTimeout</code>为<mark>0</mark>的超时。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-comment">// 避免窗口在变动时出现昂贵的计算开销。</span>
jQuery(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'resize'</span>, _.debounce(calculateLayout, <span class="hljs-number">150</span>));
 
<span class="hljs-comment">// 当点击时 `sendMail` 随后就被调用。</span>
jQuery(element).on(<span class="hljs-string">'click'</span>, _.debounce(sendMail, <span class="hljs-number">300</span>, {
  <span class="hljs-string">'leading'</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-string">'trailing'</span>: <span class="hljs-literal">false</span>
}));
 
<span class="hljs-comment">// 确保 `batchLog` 调用1次之后，1秒内会被触发。</span>
<span class="hljs-keyword">var</span> debounced = _.debounce(batchLog, <span class="hljs-number">250</span>, { <span class="hljs-string">'maxWait'</span>: <span class="hljs-number">1000</span> });
<span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">'/stream'</span>);
jQuery(source).on(<span class="hljs-string">'message'</span>, debounced);
 
<span class="hljs-comment">// 取消一个 trailing 的防抖动调用</span>
jQuery(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'popstate'</span>, debounced.cancel);
</code></div></pre>
<h3><a id="_.defer(func, [args])"></a>_.defer(func, [args])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要延迟的函数。</li>
<li>[args] (…*): 会在调用时传给 func 的参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(number):返回计时器 id。</li>
</ul>
</details></div><p>推迟调用<code>func</code>，直到当前堆栈清理完毕。 调用时，任何附加的参数会传给<code>func</code>。</p>
<pre><div class="hljs"><code class="lang-js">_.defer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-built_in">console</span>.log(text);
}, <span class="hljs-string">'deferred'</span>);
<span class="hljs-comment">// =&gt; 一毫秒或更久一些输出 'deferred'。</span>
</code></div></pre>
<h3><a id="_.delay(func, wait, [args])"></a>_.delay(func, wait, [args])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要延迟的函数。</li>
<li>wait (number): 要延迟的毫秒数。</li>
<li>[args] (…*): 会在调用时传入到 func 的参数。</li>
</ul>
<p>返回</p>
<ul>
<li>(number): 返回计时器 id</li>
</ul>
</details></div><p>延迟<code>wait</code>毫秒后调用<code>func</code>。 调用时，任何附加的参数会传给<code>func</code>。</p>
<pre><div class="hljs"><code class="lang-js">_.delay(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-built_in">console</span>.log(text);
}, <span class="hljs-number">1000</span>, <span class="hljs-string">'later'</span>);
<span class="hljs-comment">// =&gt; 一秒后输出 'later'。</span>
</code></div></pre>
<h2><a id="转换"></a>转换</h2>
<h3><a id="_.flip(func)"></a>_.flip(func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 要翻转参数的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的函数。</li>
</ul>
</details></div><p>创建一个函数，调用<code>func</code>时候接收翻转的参数。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> flipped = _.flip(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> _.toArray(<span class="hljs-built_in">arguments</span>);
});
 
flipped(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>);
<span class="hljs-comment">// =&gt; ['d', 'c', 'b', 'a']</span>
</code></div></pre>
<h3><a id="_.memoize(func, [resolver])"></a>_.memoize(func, [resolver])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 需要缓存化的函数.</li>
<li>[resolver] (Function): 这个函数的返回值作为缓存的 key。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回缓存化后的函数。</li>
</ul>
</details></div><p>创建一个会缓存<code>func</code>结果的函数。 如果提供了<code>resolver</code>，就用<code>resolver</code>的返回值作为<code>key</code>缓存函数的结果。 默认情况下用第一个参数作为缓存的<code>key</code>。 <code>func</code>在调用时<code>this</code>会绑定在缓存函数上。</p>
<div class='tip-block warning'><span class='title'> 注意: </span><p>缓存会暴露在缓存函数的<code>cache</code>上。 它是可以定制的，只要替换了<code>_.memoize.Cache</code>构造函数，或实现了Map的 <code>delete</code>, <code>get</code>, <code>has</code>, 和<code>set</code>方法。</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> object = { <span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> other = { <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span> };
 
<span class="hljs-keyword">var</span> values = _.memoize(_.values);
values(object);
<span class="hljs-comment">// =&gt; [1, 2]</span>
 
values(other);
<span class="hljs-comment">// =&gt; [3, 4]</span>
 
object.a = <span class="hljs-number">2</span>;
values(object);
<span class="hljs-comment">// =&gt; [1, 2]</span>
 
<span class="hljs-comment">// 修改结果缓存。</span>
values.cache.set(object, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
values(object);
<span class="hljs-comment">// =&gt; ['a', 'b']</span>
 
<span class="hljs-comment">// 替换 `_.memoize.Cache`。</span>
_.memoize.Cache = <span class="hljs-built_in">WeakMap</span>;
</code></div></pre>
<h3><a id="_.negate(predicate:Function)"></a>_.negate(predicate:Function)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>predicate (Function): 需要对结果取反的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回一个新的取反函数。</li>
</ul>
</details></div><p>创建一个针对断言函数<code>func</code>结果取反的函数。 <code>func</code>断言函数被调用的时候, <code>this</code>绑定到创建的函数，并传入对应参数。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}
 
_.filter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], _.negate(isEven));
<span class="hljs-comment">// =&gt; [1, 3, 5]</span>
</code></div></pre>
<h3><a id="_.once(func)"></a>_.once(func)</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function): 指定的触发的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新的受限函数。</li>
</ul>
</details></div><p>创建一个只能调用<code>func</code>一次的函数。重复调用返回第一次调用的结果。<code>func</code>调用时，<code>this</code>绑定到创建的函数，并传入对应参数。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> initialize = _.once(createApplication);
initializ	e();
initialize();
<span class="hljs-comment">// `initialize` 只能调用 `createApplication` 一次。</span>
</code></div></pre>
<h3><a id="_.overArgs(func, [transforms = [ _.identity ]])"></a>_.overArgs(func, [transforms = [ _.identity ]])</h3>
<div class='more-block'><details><summary>参数</summary>
<ul>
<li>func (Function):要包裹的函数。</li>
</ul>
<p>返回</p>
<ul>
<li>(Function): 返回新函数。</li>
</ul>
</details></div><p>创建一个函数，调用func时参数为相对应的<code>transforms</code>的返回值。</p>
<div class='tip-block info'><p>执行func函数之前，需要通过<code>transforms</code> 处理参数；</p>
</div><pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doubled</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n * n;
}
 
<span class="hljs-keyword">var</span> func = _.overArgs(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> [x, y];
}, [square, doubled]);
 
func(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [81, 6]</span>
 
func(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);
<span class="hljs-comment">// =&gt; [100, 10]</span>
</code></div></pre>
<p>或</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> func = _.overArgs(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> x + y;
}, [square, doubled]);

func(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; 87</span>
</code></div></pre>
</div>
</body>
<script src="/js/prism.js"></script>
<script>
    window.onload = function() {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
    }
</script>

</html>