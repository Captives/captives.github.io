<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/code-style.css">
    <link rel="stylesheet" href="/css/page.css"> 
    <title>数组Array</title>
</head>

<body>
    
    <div class="content"><h1><a id="数组Array"></a>数组Array</h1>
<h2><a id="数据交换"></a>数据交换</h2>
<h3><a id="普通做法"></a>普通做法</h3>
<p>就是引入临时变量tmp,适用范围广；是最简单、直观、也是最高效的；但是，会增加内存的使用。</p>
<pre><code class="lang-js">function exchange(a, b) {
    let c = a;
    a = b;
    b = c;
    return [a, b];
}
</code></pre>
<h3><a id="算术运算"></a>算术运算</h3>
<p>适用范围，仅支持数字；<br />
通过算术运算过程中的技巧，可以巧妙地将两个值进行互换。但是，有个缺点就是变量数据溢出。因为JavaScript能存储数字的精度范围是-253到253。所以，加法运算，会存在溢出的问题。<br />
方式一：</p>
<pre><code class="lang-js">function exchange(a, b) {
    a = a + b;
    b = a - b;
    a = a - b;
    return [a, b];
}

</code></pre>
<p>方式二：</p>
<pre><code class="lang-js">function exchange(a, b) {
     a = b - a + (b = a); //等价于方式三
    return [a, b];
}

</code></pre>
<p>方式三：</p>
<pre><code class="lang-js">function exchange(a, b) {
    let c = b;
    b = a;
    a = c - a + b;
    return [a, b];
}
</code></pre>
<h3><a id="数组方式"></a>数组方式</h3>
<pre><code class="lang-js">function exchange(a, b) {
    a = [a, b]; 
    b = a[0];
    a = a[1];
    return [a, b];
}
</code></pre>
<p>等价于</p>
<pre><code class="lang-js">function exchange(a, b) {
    a = [b, b = a][0];
    return [a, b];
}
</code></pre>
<h3><a id="对象方式"></a>对象方式</h3>
<p>和数组方式类似，利用对象的键值对进行数据交换。</p>
<pre><code class="lang-js">function exchange(a, b) {
    a = { a: b, b: a };
    b = a.b;
    a = a.a;
    return [a, b]; 
}
</code></pre>
<h3><a id="ES6解构"></a>ES6解构</h3>
<p>用解构的语法特性，一次性解决，简单暴力，哈哈哈~<br />
更重要的一点：解构语法还适用于其他类型的变量进行互换。所以，用解构可以很easy地进行互换。</p>
<pre><code class="lang-js">function exchange(a, b) {
    [a, b] = [b, a];
    return [a, b];
}
console.log(exchange(3, 6)); //[6, 3]
</code></pre>
<h3><a id="异或操作"></a>异或操作</h3>
<p>巧用位运算的技巧，利用 a ^ b ^ b == a 的特点，进行数值交换，避免了使用算术运算带来的弊端，不会发生溢出问题。</p>
<pre><code class="lang-js">function exchange(a, b) {
    a ^= b;
    b ^= a;
    a ^= b;
    return [a, b];
}
</code></pre>
<p>或者</p>
<pre><code class="lang-js">function exchange(a, b) {
    a = (b = (a ^= b) ^ b) ^ a;
    return [a, b];
}
</code></pre>
<h2><a id="排序"></a>排序</h2>
<h2><a id="去重"></a>去重</h2>
<h3><a id="正序去重复"></a>正序去重复</h3>
<pre><code class="lang-js">const list = [2, 1, 3, 45, 5, 4, 3, 2, 4, 5];

function distinct(list) {
    for (let i = 0; i &lt; list.length; i++) {
        //如果有相同的值,不同的索引,删除当前数据
        if (list.indexOf(list[i]) != i) {
            list.splice(i, 1);
            i--; //删除后索引回退
        }
    }
    return list;
}

console.log(distinct(list)); //[ 2, 1, 3, 45, 5, 4 ]
</code></pre>
<h3><a id="倒序去重复"></a>倒序去重复</h3>
<pre><code class="lang-js">const list = [2, 1, 3, 45, 5, 4, 3, 2, 4, 5];
function distinct(list) {
    for (let i = list.length - 1; i &gt;= 0; i--) {
        //如果有相同的值,不同的索引,删除当前数据
        if (list.indexOf(list[i]) != i) {
            list.splice(i, 1);
        }
    }
    return list;
}

console.log(distinct(list)); //[ 2, 1, 3, 45, 5, 4 ]
</code></pre>
<h2><a id="删除"></a>删除</h2>
<h2><a id="排序"></a>排序</h2>
<h3><a id="普通排序"></a>普通排序</h3>
<pre><code class="lang-js">list.sort((a, b) =&gt; a - b); // 正序
list.sort((a, b) =&gt; b - a); // 倒序
</code></pre>
</div>
</body>
<script src="/js/prism.js"></script>
<script>
    window.onload = function() {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
    }
</script>

</html>