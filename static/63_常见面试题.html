<!DOCTYPE html>
<html>

</html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>常见面试题</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <!-- Bootstrap CSS-->
    <link rel="stylesheet" href="/vendor/bootstrap/css/bootstrap.min.css">
    <!-- theme stylesheet-->
    <link rel="stylesheet" href="/css/style.default.css" id="theme-stylesheet">
    <!-- code stylesheet-->
    <link rel="stylesheet" href="/css/page.css">
    <!-- Custom stylesheet-->
    <link rel="stylesheet" href="/css/custom.css">
    <!-- Favicon-->
    <link rel="shortcut icon" href="/img/favicon.png">
    <!-- Tweaks for older IEs-->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->
</head>

<body>
    <div id="all">
        <div class="container-fluid">
            <div class="row row-offcanvas row-offcanvas-left">
                <!--   *** SIDEBAR ***-->
<div id="sidebar" class="col-md-4 col-lg-3 sidebar-offcanvas">
    <div class="sidebar-content">
        <h1 class="sidebar-heading">
            <a href="/index.html">Creative</a>
        </h1>
        <p class="sidebar-p">I am a creative illustrator and graphic designer with more than 10 years of experience. </p>
        <p class="sidebar-p">Originally from Toronto, currently based in London. </p>
        <ul class="sidebar-menu">
            <li class="sidebar-item">
                <a href="/index.html" class="sidebar-link">首页</a>
            </li>
            <li class="sidebar-item">
                <a href="/article.html" class="sidebar-link">文章</a>
            </li>
            <li class="sidebar-item">
                <a href="/favorite.html" class="sidebar-link">收藏夹</a>
            </li>
            <li class="sidebar-item">
                <a href="/contact.html" class="sidebar-link">联系我</a>
            </li>
        </ul>
        <p class="social">
            <a href="#" data-animate-hover="pulse" class="external facebook">
                <i class="fa fa-facebook"></i>
            </a>
            <a href="#" data-animate-hover="pulse" class="external gplus">
                <i class="fa fa-google-plus"></i>
            </a>
            <a href="#" data-animate-hover="pulse" class="external twitter">
                <i class="fa fa-twitter"></i>
            </a>
            <a href="#" title="" class="external instagram">
                <i class="fa fa-instagram"></i>
            </a>
            <a href="#" data-animate-hover="pulse" class="email">
                <i class="fa fa-envelope"></i>
            </a>
        </p>
    </div>
</div>
<!--   *** SIDEBAR END ***  -->
                <!--*** DETAIL ***-->
                <div class="col-md-8 col-lg-9 content-column white-background">
                    <div class="small-navbar d-flex d-md-none">
    <button type="button" data-toggle="offcanvas" class="btn btn-outline-primary"> <i class="fa fa-align-left mr-2"></i>Menu</button>
    <h1 class="small-navbar-heading"> <a href="index.html">Creative </a></h1>
</div>
                    <div class="row">
                        <div class="col-xl-10">
                            <div class="content-column-content">
                                <h2><a id="JavaScript"></a>JavaScript</h2>
<h3><a id="介绍js有哪些内置对象？"></a>介绍js有哪些内置对象？</h3>
<blockquote>
<p>String、Number、Boolean、Array、Object、Math、Date、RegExp …</p>
</blockquote>
<h3><a id="数据类型"></a>数据类型</h3>
<blockquote>
<p>基本类型：String、Number、Boolean、null、undefined、Symbol<br />
引用类型：Object（Arry、Map、Function）</p>
</blockquote>
<p>Symbol：<br />
ES6引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。<br />
<code>Symbol</code>函数栈不能用<code>new</code>命令，因为<code>Symbol</code>是原始数据类型，不是对象。</p>
<div class='tip-block warning'><span class='title'> 注意： </span><p>Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for…in 、 for…of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> data = {};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    data[<span class="hljs-built_in">Symbol</span>(i)] = i;
}
<span class="hljs-built_in">console</span>.log(data);				<span class="hljs-comment">//</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(data));			<span class="hljs-comment">//[]</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.ownKeys(data));		 <span class="hljs-comment">//[Symbol(0),Symbol(1) ...]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(data)); <span class="hljs-comment">//[Symbol(0),Symbol(1) ...]</span>

<span class="hljs-built_in">Reflect</span>.ownKeys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(key, data[key]); <span class="hljs-comment">// Symbol(0) 0 ....</span>
})
</code></div></pre>
<p><a href="https://www.runoob.com/w3cnote/es6-symbol.html" target="_blank">ES6 Symbol API</a></p>
</div><h3><a id="undefined 和 null 区别"></a>undefined 和 null 区别</h3>
<p>1、null<br />
语义表示空值，定义了，但是为空值；空对象指针类型<br />
（1）作为函数的参数，表示该函数的参数不是对象。<br />
（2）作为对象原型链的终点。</p>
<p>2、undefined<br />
表示未定义，声明了一个变量未初始化时，得到的就是<code>undefined</code><br />
（1）变量被声明了，但没有赋值时，就等于undefined。<br />
（2）调用函数时，应该提供的参数没有提供，该参数就等于undefined。<br />
（3）对象没有赋值的属性，该属性的值为undefined。<br />
（4）函数没有返回值时，默认返回undefined。</p>
<p>3、区别</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>             <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>                  <span class="hljs-comment">// object</span>
<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>           <span class="hljs-comment">// false</span>
<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>            <span class="hljs-comment">// true</span>
</code></div></pre>
<h3><a id="JavaScript有几种类型的值？"></a>JavaScript有几种类型的值？</h3>
<blockquote>
<p>栈：原始数据类型（Undefined、Null、Boolean、Number、String）<br />
堆：引用数据类型（对象、数组、函数）</p>
</blockquote>
<h3><a id="对this的理解"></a>对this的理解</h3>
<p>1、单独使用，this表示全局对象<br />
2、在函数中，this表示全局对象<br />
3、在对象的一个函数方法中，this表示这个对象<br />
4、可以通过apply、bind来更改this的指向</p>
<blockquote>
<p>ps：this永远指向的是最后调用它的对象，仅当它在对象的一个函数方法中时会有差异</p>
</blockquote>
<h3><a id="if有作用域吗?"></a>if有作用域吗?</h3>
<p>只有函数有作用域，if是没有作用域的。</p>
<p>但是有一种情况会让if看上去有作用域，就是在if {}语句中，使用const、let，他们会有块级作用域。</p>
<h3><a id="原型链和作用域链的区别"></a>原型链和作用域链的区别</h3>
<ol>
<li>原型链<br />
当访问一个对象的某个属性时，会先在这个对象本身的属性上找，如果没有找到，会去这个属性的__proto__属性上找，即这个构造函数的prototype，如果还没找到，就会继续在__proto__上查找，直到最顶层，找不到即为undefined。这样一层一层往上找，彷佛是一条链子串起来，所以叫做原型链。</li>
</ol>
<ul>
<li>
<ul>
<li>对象 obj --&gt; Object.prototype --&gt; null;</li>
</ul>
</li>
<li>
<ul>
<li>函数 fun --&gt; Function.prototype --&gt; Object.prototype --&gt; null</li>
</ul>
</li>
<li>
<ul>
<li>数组 arr --&gt; Array.prototype --&gt; Object.prototype --&gt; null</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>作用域链<br />
变量取值会到创建这个变量的函数的作用域中取值，如果找不到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p>
</li>
<li>
<p>区别<br />
作用域是对变量而言，原型链是对于对象的属性而言<br />
作用域链的顶层是window，原型链的顶层是Object</p>
</li>
</ol>
<h3><a id="JS 原型链"></a>JS 原型链</h3>
<ul>
<li>对象 obj --&gt; Object.prototype --&gt; null;</li>
<li>函数 fun --&gt; Function.prototype --&gt; Object.prototype --&gt; null</li>
</ul>
<h3><a id="写出代码的打印结果"></a>写出代码的打印结果</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> foo = {};
<span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};

<span class="hljs-built_in">Object</span>.prototype.a = <span class="hljs-string">"value a"</span>;
<span class="hljs-built_in">Function</span>.prototype.b = <span class="hljs-string">"value b"</span>;

<span class="hljs-built_in">console</span>.log(foo.a); 	<span class="hljs-comment">//value a</span>
<span class="hljs-built_in">console</span>.log(foo.b);	<span class="hljs-comment">//undefined</span>

<span class="hljs-built_in">console</span>.log(F.a);	<span class="hljs-comment">//value a</span>
<span class="hljs-built_in">console</span>.log(F.b);	<span class="hljs-comment">//value b</span>
</code></div></pre>
<h3><a id="js 判断类型(typeof、instanceOf)区别"></a>js 判断类型(typeof、instanceOf)区别</h3>
<p>1、typeof</p>
<p>可以用此来判断number, string, object, boolean, function, undefined, symbol</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>‘string’</td>
</tr>
<tr>
<td>Number</td>
<td>‘number’</td>
</tr>
<tr>
<td>Boolean</td>
<td>‘boolean’</td>
</tr>
<tr>
<td>Undefined</td>
<td>‘undefined’</td>
</tr>
<tr>
<td>Object</td>
<td>‘object’</td>
</tr>
<tr>
<td>function</td>
<td>‘function’</td>
</tr>
<tr>
<td>Symbol</td>
<td>‘symbol’</td>
</tr>
</tbody>
</table>
<p>检测不出<mark>null</mark>和<mark>数组</mark>,<mark>对象</mark>，结果都为<code>object</code></p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-number">1</span> <span class="hljs-string">"number"</span>
<span class="hljs-number">124</span> string
<span class="hljs-literal">null</span> <span class="hljs-string">"object"</span> <span class="hljs-comment">//null值表示一个空对象指针</span>
<span class="hljs-literal">true</span> <span class="hljs-string">"boolean"</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-string">"object"</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-string">"object"</span>
</code></div></pre>
<p>2、instanceof<br />
<code>instanceof</code>运算符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上,返回值为布尔值，用于指示一个变量是否属于某个对象的实例。<br />
其语法如下所示：</p>
<pre><div class="hljs"><code class="lang-js">object <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">constructor</span>
</code></div></pre>
<p><code>instanceof</code>主要的实现原理就是只要右边变量的<code>prototype</code>在左边变量的原型链上即可。因此，<code>instanceof</code>在查找的过程中会遍历左边变量的原型链，直到找到右边变量的<code>prototype</code>，如果查找失败，则会返回 false.</p>
<p>不能检测出<mark>number</mark>、<mark>boolean</mark>、<mark>string</mark>、<mark>undefined</mark>、<mark>null</mark>、<mark>symbol</mark>类型，所以<code>instancof</code>常用于检测复杂类型以及级成关系</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">const</span> f = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> h = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> i = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

<span class="hljs-built_in">console</span>.log(f, f <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span>); <span class="hljs-comment">//false</span>
<span class="hljs-built_in">console</span>.log(h, h <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(i, i <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>); <span class="hljs-comment">//true</span>
</code></div></pre>
<h4><a id="代码实现instanceOf"></a>代码实现instanceOf</h4>
<p>方法一：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instanceOf</span>(<span class="hljs-params">s, t</span>)</span>{
  <span class="hljs-keyword">var</span> p = s;
  <span class="hljs-keyword">while</span>(p){
    <span class="hljs-keyword">if</span>(p === t.prototype){
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    p = p.__proto__;
  }
 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></div></pre>
<p>方法二：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instanceOf</span>(<span class="hljs-params">left, right</span>) </span>{
    <span class="hljs-keyword">let</span> leftVal = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);
    <span class="hljs-keyword">const</span> rightVal = right.prototype;

    <span class="hljs-keyword">while</span> (leftVal !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (leftVal === rightVal)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        leftVal = <span class="hljs-built_in">Object</span>.getPrototypeOf(leftVal);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></div></pre>
<p>3、constructor<br />
<mark>null</mark>、<mark>undefined</mark>没有<mark>construstor</mark>方法，因此<code>constructor</code>不能判断<mark>undefined</mark>和<mark>null</mark>。但是<code>contructor</code>的指向是可以被改变，所以不安全</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].constructor === <span class="hljs-built_in">Array</span>) <span class="hljs-comment">// ture</span>
</code></div></pre>
<p>4、Object.prototype.toString.call<br />
全类型都可以判断</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">Object</span>.prototype.toString.call([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) <span class="hljs-comment">// [object Array]</span>
</code></div></pre>
<h3><a id="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h3>
<p>1、普通函数<br />
可以通过bind、call、apply改变this指向<br />
可以使用new</p>
<p>2、箭头函数<br />
本身没有this指向，<br />
它的this在定义的时候继承自外层第一个普通函数的this<br />
被继承的普通函数的this指向改变，箭头函数的this指向会跟着改变<br />
箭头函数外层没有普通函数时，this指向window<br />
不能通过bind、call、apply改变this指向<br />
使用new调用箭头函数会报错，因为箭头函数没有constructor</p>
<h3><a id="document.write和innerHTML的区别"></a>document.write和innerHTML的区别</h3>
<p>document.write 将内容写入页面，清空替换掉原来的内容，会导致重绘<br />
document.innerHTML 将内容写入某个Dom节点，不会重绘</p>
<h3><a id="栈和堆的区别"></a>栈和堆的区别</h3>
<p>1、堆<br />
动态分配内存，内存大小不一，也不会自动释放</p>
<p>2、栈<br />
自动分配相对固定大小的内存空间，并由系统自动释放</p>
<p>3、基本类型都是存储在栈中，每种类型的数据占用的空间的大小是确定的，并由系统自动分配和释放。内存可以及时回收。</p>
<p>4、引用类型的数据都是存储在堆中。准确说是栈中会存储这些数据的地址指针，并指向堆中的具体数据。</p>
<h3><a id="bind、call、apply的区别"></a>bind、call、apply的区别</h3>
<p>三者均可以更改<code>this</code>指向, 可以编写<strong>能够在不同对象上</strong>使用的方法。</p>
<p>1、bind<br />
bind(thisArg, arg…) 方法<strong>创建</strong>一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用;</p>
<blockquote>
<p>例如，f.bind(obj)，实际上可以理解为obj.f()，这时，f函数体内的this自然指向的是obj</p>
</blockquote>
<p>返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Seven"</span>,
    <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">city</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-string">" in "</span> + city;
    }
}

<span class="hljs-built_in">console</span>.log(person.fullName(<span class="hljs-string">'HZ'</span>)); 

<span class="hljs-keyword">var</span> name = <span class="hljs-string">"window"</span>;

<span class="hljs-keyword">var</span> func = person.fullName.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'CH'</span>); <span class="hljs-comment">//更改指向到Window</span>
<span class="hljs-built_in">console</span>.log(func());
<span class="hljs-built_in">console</span>.log(person.fullName(<span class="hljs-string">'HZ'</span>));

<span class="hljs-comment">//Seven in HZ</span>
<span class="hljs-comment">//window in CH</span>
<span class="hljs-comment">//Seven in HZ</span>
</code></div></pre>
<p>代码实现<code>bind</code>：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">Function</span>.prototype.bind1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'The bound object needs to be a function'</span>);
    }

    <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">const</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
    <span class="hljs-keyword">const</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...fBoundArgs</span>) </span>{
        <span class="hljs-comment">// 指定this</span>
        <span class="hljs-comment">// 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true</span>
        <span class="hljs-keyword">return</span> self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> fNOP ? <span class="hljs-keyword">this</span> : context, [...args, ...fBoundArgs]);
    }

    <span class="hljs-comment">//  修改返回函数的 prototype 为绑定函数的 prototype,为了避免直接修改this的原型，所以新建了一个fNOP函数作为中介</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.prototype) {
        fNOP.prototype = <span class="hljs-keyword">this</span>.prototype;
    }
    fBound.prototype = <span class="hljs-keyword">new</span> fNOP();

    <span class="hljs-keyword">return</span> fBound;
}
</code></div></pre>
<p>2、call<br />
使用<code>call(thisArg, arg...)</code>方法，您可以编写<strong>能够在不同对象上</strong>使用的方法。<br />
使用一个指定的this对象和给出的参数来调用函数；</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> person = {
    <span class="hljs-attr">firstName</span>:<span class="hljs-string">"Seven"</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">"A"</span>,
    <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">city</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastName + <span class="hljs-string">" at "</span> + city;
    }
}
<span class="hljs-keyword">var</span> person1 = {
    <span class="hljs-attr">firstName</span>:<span class="hljs-string">"Bill"</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Gates"</span>,
}
<span class="hljs-keyword">var</span> person2 = {
    <span class="hljs-attr">firstName</span>:<span class="hljs-string">"Steve"</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Jobs"</span>,
}

person.fullName(<span class="hljs-string">'SH'</span>);	<span class="hljs-comment">// 将返回 "Seven A in SH"</span>
person.fullName.call(person1, <span class="hljs-string">"HZ"</span>);  <span class="hljs-comment">// 将返回 "Bill Gates in HZ"</span>
person.fullName.call(person2, <span class="hljs-string">"HN"</span>);  <span class="hljs-comment">// 将返回 "Steve Jobs in HN"</span>
</code></div></pre>
<div class='tip-block warning'><p><mark>thisArg</mark>可以为<code>null</code>，<code>undefined</code>，此时函数内的<mark>this</mark>指向<code>Window</code>。<br />
<mark>thisArg</mark>可以传基本数据类型，原生<code>call</code>会自动用<code>Object()</code>转换<br />
函数可以有返回值，没有返回值，返回<code>undefined</code><br />
将函数添加到指定对象中，并用delete删除(消除副作用)</p>
</div><p>代码实现<code>call</code>：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">Function</span>.prototype.call1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) </span>{
    <span class="hljs-comment">// 获取第一个参数（注意第一个参数为null或undefined，this指向window），构建对象</span>
    context = context ? <span class="hljs-built_in">Object</span>(context) : <span class="hljs-built_in">window</span>;
    <span class="hljs-comment">// 将对应函数传入该对象中</span>
    context.fn = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 获取参数并执行相应函数</span>
    <span class="hljs-keyword">let</span> result = context.fn(...args);
    <span class="hljs-comment">// 删除该对象中的函数，消除副作用</span>
    <span class="hljs-keyword">delete</span> context.fn;
}
</code></div></pre>
<p>3、apply<br />
使用<code>apply(thisArg, [])</code>方法，您可以编写<strong>能够在不同对象上</strong>使用的方法。<br />
<code>apply()</code>方法与<code>call()</code>方法非常相似，不同之处：</p>
<ul>
<li><code>call()</code>方法分别接受参数。</li>
<li><code>apply()</code>方法接受数组形式的参数。</li>
</ul>
<p>如果要使用数组而不是参数列表，则 apply() 方法非常方便。<br />
代码实现：</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">Function</span>.prototype.apply1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, arr</span>) </span>{
    <span class="hljs-comment">// 获取第一个参数（注意第一个参数为null或undefined，this指向window），构建对象</span>
    context = context ? <span class="hljs-built_in">Object</span>(context) : <span class="hljs-built_in">window</span>;
    
    <span class="hljs-comment">// 将对应函数传入该对象中</span>
    context.fn = <span class="hljs-keyword">this</span>;

    <span class="hljs-comment">// 获取参数并执行相应函数</span>
    <span class="hljs-keyword">let</span> result = arr ? context.fn(...arr) : context.fn();
     
    <span class="hljs-comment">// 删除该对象中的函数，消除副作用</span>
    <span class="hljs-keyword">delete</span> context.fn;

    <span class="hljs-comment">//返回值</span>
    <span class="hljs-keyword">return</span> result;
}
</code></div></pre>
<div class='tip-block info'><p>bind方法可以让函数想什么时候调用就什么时候调用。<br />
apply、call方法只是临时改变了this指向。</p>
</div><p>参考<a href="https://mp.weixin.qq.com/s?__biz=MzIxMjExNzQxMQ==&amp;mid=2247483892&amp;idx=1&amp;chksm=https://mp.weixin.qq.com/s?__biz=MzIxMjExNzQxMQ==&amp;mid=2247483892&amp;idx=1&amp;sn=049ee4a8dfee3a03e253a13e96ef5f54&amp;chksm=974bb338a03c3a2eba3eb528161be4155f9d7153beefd9f02f07d8e997acd3bcaf5b9f193453&amp;scene=21&amp;scene=21" target="_blank">图解JavaScript——代码实现（Object.create()、flat()等十四种代码原理）</a></p>
<h3><a id="eval()"></a>eval()</h3>
<p>eval(string) 函数计算<code>JavaScript</code>字符串，并把它作为脚本代码来执行<br />
如果参数是一个表达式，<code>eval()</code>函数将执行表达式；<br />
如果参数是<code>Javascript</code>语句，<code>eval()</code>将执行<code>Javascript</code>语句；<br />
如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。<br />
特殊：eval(&quot;{b:2}&quot;) // 声明一个对象<br />
　eval(&quot;（{b:2}）&quot;) // 返回对象{b:2}</p>
<h3><a id="JS哪些操作会造成内存泄露"></a>JS哪些操作会造成内存泄露</h3>
<p>内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。<br />
1、意外的全局变量<br />
2、闭包<br />
3、没有清理的dom元素；dom元素赋值给变量，又通过removeChild移除dom元素。但是dom元素的引用还在内存中<br />
4、被遗忘的定时器或者回调<br />
<a href="https://www.jianshu.com/p/763ba9562864" target="_blank">扩展文章</a></p>
<h3><a id="什么是闭包，如何使用它，为什么要使用它？"></a>什么是闭包，如何使用它，为什么要使用它？</h3>
<p>（1）闭包就是能够读取其它函数内部变量的函数<br />
（2）使用方法：在一个函数内部创建另一个函数<br />
（3）最大用处有两个：读取其他函数的变量值，让这些变量始终保存在内存中<br />
（4）缺点：会引起内存泄漏（引用无法被销毁，一直存在）</p>
<h3><a id="请解释JSONP的工作原理，以及它为什么不是真正的AJAX"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX</h3>
<p>JSONP 是一种非正式传输协议，允许用户传递一个callback给服务端，然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。<br />
当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。<br />
它们的实质不同<br />
ajax的核心是通过xmlHttpRequest获取非本页内容<br />
jsonp的核心是动态添加script标签调用服务器提供的js脚本<br />
jsonp只支持get请求，ajax支持get和post请求</p>
<h3><a id="请解释一下JavaScript的同源策略"></a>请解释一下JavaScript的同源策略</h3>
<p>同源指协议，域名，端口相同，<br />
同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h2><a id="面试题"></a>面试题</h2>
<h3><a id="写出如下代码的打印结果"></a>写出如下代码的打印结果</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Tom'</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name == <span class="hljs-string">'undefined'</span>) {
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Jack'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Goodbye '</span> + name);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello '</span> + name);
}
})();

<span class="hljs-comment">// name undefined</span>
<span class="hljs-comment">// typeof name undefined</span>
<span class="hljs-comment">// Goodbye Jack</span>
</code></div></pre>
<p>第四行<code>var</code>声明的变量没有块作用域，变量会提升到最近的<code>function</code>作用域的上层，但此时只是声明了变量，并没有赋值，到实际运行了赋值语句之后才有值，在之前值为<code>undefined</code>;</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Tom'</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name == <span class="hljs-string">'undefined'</span>) {
  name = <span class="hljs-string">'Jack'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Goodbye '</span> + name);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello '</span> + name);
}
})();

<span class="hljs-comment">// Hello Tom</span>
</code></div></pre>
<p>1、首先在进入函数作用域当中，获取name属性<br />
2、在当前作用域没有找到name<br />
3、通过作用域链找到最外层，得到name属性<br />
4、执行else的内容，得到Hello Tom</p>
<h3><a id="输出以下代码运行结果"></a>输出以下代码运行结果</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-number">1</span> + <span class="hljs-string">"1"</span>				<span class="hljs-comment">// '11'</span>

<span class="hljs-number">2</span> * <span class="hljs-string">"2"</span>				<span class="hljs-comment">// 4</span>
	
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]			<span class="hljs-comment">// '1,22,1'</span>

<span class="hljs-string">"a"</span> + + <span class="hljs-string">"b"</span>			<span class="hljs-comment">// 'aNaN'</span>
</code></div></pre>
<p>1 + “1”<br />
加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来<br />
所以值为：“11”</p>
<p>2 * “2”<br />
乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值</p>
<p>[1, 2] + [2, 1]<br />
Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。<br />
所以两个数组对象的toString方法相加，值为：“1,22,1”</p>
<p>“a” + + “b”<br />
后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。<br />
所以值为：“aNaN”</p>
<p>以上均参考：《Javascript高级程序设计》</p>
<h3><a id="介绍暂时性死区"></a>介绍暂时性死区</h3>
<p>在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p>
<h3><a id="两个对象如何比较"></a>两个对象如何比较</h3>
<p>思路步骤：</p>
<ul>
<li>1、判断两个类型是否对象</li>
<li>2、判断两个对象key的长度是否一致</li>
<li>3、判断属性value值的数据类型，根据不同数据类型做比较</li>
<li>
<ul>
<li>a、是对象，重复这个步骤</li>
</ul>
</li>
<li>
<ul>
<li>b、是数组，转字符串比较</li>
</ul>
</li>
<li>
<ul>
<li>c、是基本类型，直接判断</li>
</ul>
</li>
</ul>
<h3><a id="Promise和Async处理失败的时候有什么区别"></a>Promise和Async处理失败的时候有什么区别</h3>
<ul>
<li>1、Promise错误可以在构造体里面被捕获，而async/await返回的是promise,可以通过catch直接捕获错误。</li>
<li>2、await 后接的Promise.reject都必须被捕获，否则会中断执行</li>
</ul>
<h3><a id="JS为什么要区分微任务和宏任务"></a>JS为什么要区分微任务和宏任务</h3>
<p>1、js是单线程的，但是分同步异步<br />
2、微任务和宏任务皆为异步任务，它们都属于一个队列<br />
3、宏任务一般是：script，setTimeout，setInterval、setImmediate<br />
4、微任务：原生Promise<br />
5、遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务</p>
<h3><a id="setTimeout(0)和setTimeout(2)之间的区别"></a>setTimeout(0)和setTimeout(2)之间的区别</h3>
<p>定时器表面意思是过指定时间后执行，但是真正的含义是每过指定时间后，会有fn进入事件队列<br />
1、setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行<br />
2、setTimeout(fn,1) 1毫秒后执行，但是因为要先执行前面的宏任务，所以不一定就是在一毫秒后执行，取决于队列里任务执行的速度</p>
<h3><a id="for..in 和 object.keys的区别"></a>for…in 和 object.keys的区别</h3>
<p>1、Object.keys不会遍历继承的原型属性<br />
2、for…in 会遍历继承的原型属性</p>
<h3><a id="说说你对AMD和Commonjs的理解"></a>说说你对AMD和Commonjs的理解</h3>
<p>两者都是为了实现模块化编程而出现的<br />
（1）commonjs<br />
通常被应用于服务器，在服务器端，模块的加载和执行都在本地完成，因此，CommonJS并不要求模块加载的异步化。<br />
核心思想：<br />
一个单独文件就是一个模块，通过require方法来同步加载要依赖的模块，然后通过extports或则module.exports来导出需要暴露的接口。<br />
（2）AMD<br />
可以实现异步加载依赖模块，预加载，在并行加载js文件同时，还会解析执行该模块。虽然可以并行加载，异步处理，但是加载顺序不一定<br />
（3）CMD<br />
懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。</p>
<h3><a id="js设计模式"></a>js设计模式</h3>
<ul>
<li>单例模式</li>
<li>策略模式</li>
<li>代理模式</li>
<li>迭代器模式</li>
<li>发布—订阅模式</li>
<li>命令模式</li>
<li>组合模式</li>
<li>模板方法模式</li>
<li>享元模式</li>
<li>职责链模式</li>
<li>中介者模式</li>
<li>装饰者模式</li>
<li>状态模式</li>
<li>适配器模式</li>
<li>外观模式<br />
以上均参考：<a href="https://www.cnblogs.com/imwtr/p/9451129.html" target="_blank">《JavaScript中常见的十五种设计模式》</a></li>
</ul>
<h3><a id="["1", "2", "3"].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3>
<div class='tip-block info'><span class='title'> map用法： </span><pre><div class="hljs"><code class="lang-js">arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, index, arr</span>) </span>{
    <span class="hljs-keyword">return</span> el
})
el：遍历过程中的当前项，
index：遍历过程中的当前下标
arr: 原数组

<span class="hljs-built_in">parseInt</span>(str, redix)
str: 要解析的字符串，如果字符第一个数不能被转换，返回<span class="hljs-literal">NaN</span>。
redix: 基数，介于 <span class="hljs-number">2</span> ~ <span class="hljs-number">36</span> 之间进制数，如果传<span class="hljs-number">0</span>，则默认用<span class="hljs-number">10</span>计算。num不在区间内，返回<span class="hljs-literal">NaN</span>
</code></div></pre>
</div><p>[“1”, “2”, “3”].map(parseInt)<br />
等价于<br />
[“1”, “2”, “3”].map((item,index) =&gt; parseInt(item, index)); //[1, NaN, NaN]</p>
<h3><a id="常见兼容性问题？"></a>常见兼容性问题？</h3>
<ul>
<li>1、事件对象兼容</li>
</ul>
<blockquote>
<p>e = e || window.event;</p>
</blockquote>
<ul>
<li>2、阻止事件冒泡兼容</li>
</ul>
<blockquote>
<p>event.stopPropagation? event.stopPropagation():event.cancelBubble=true;</p>
</blockquote>
<ul>
<li>3、阻止默认行为兼容</li>
</ul>
<blockquote>
<p>evt.preventDefault?evt.preventDefault():evt.returnValue=false;</p>
</blockquote>
<ul>
<li>4、事件监听兼容</li>
</ul>
<blockquote>
<p>addEventListener  ? addEventListener  : attachEvent()<br />
removeEventListener() ? removeEventListener() : detachEvent()</p>
</blockquote>
<ul>
<li>5、事件目标对象兼容</li>
</ul>
<blockquote>
<p>var src = event.target || event.srcElement;</p>
</blockquote>
<h2><a id="Vue 相关"></a>Vue 相关</h2>
<hr />
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjExNzQxMQ==&amp;mid=2247484353&amp;idx=1&amp;sn=f00f78052b30d16497cbba10bd39bb1d&amp;chksm=974bb10da03c381bca279aaf8a317b98e119d00b5696691f53978d39518a2231c15d4a2ca05e" target="_blank">前端高频手撕算法题36道</a></p>

                            </div>
                             <div class="content-column-content">
                                <div>
                                 上一个：<a href="/static/62_JavaScript 二叉树.html"> JavaScript 二叉树</a>
                                </div>
                                <div>
                                     下一个： <a href="/static/64_JavaScript 基础.html"> JavaScript 基础</a>
                                </div>
                             </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- JavaScript files-->
    <script src="/vendor/jquery/jquery.min.js"></script>
    <script src="/vendor/popper.js/umd/popper.min.js"></script>
    <script src="/vendor/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/prism.js"></script>
    <script>
        window.onload = function() {
            window.Prism = window.Prism || {};
            window.Prism.manual = true;
        }
    </script>
    <script>
    // ------------------------------------------------------ //
    // Main slider
    // ------------------------------------------------------ //
    // $('#main-slider').owlCarousel({
    //     items: 1,
    //     nav: false,
    //     dots: true,
    //     autoplay: true,
    //     autoplayHoverPause: true
    // });
    </script>
    <script src="/js/front.js "></script>
</body>