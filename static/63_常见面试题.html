<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/code-style.css">
    <link rel="stylesheet" href="/css/page.css"> 
    <title>常见面试题</title>
</head>

<body>
    
    <div class="content"><h2><a id="JavaScript"></a>JavaScript</h2>
<h3><a id="原型链和作用域链的区别"></a>原型链和作用域链的区别</h3>
<ol>
<li>
<p>原型链<br />
当访问一个对象的某个属性时，会先在这个对象本身的属性上找，如果没有找到，会去这个属性的__proto__属性上找，即这个构造函数的prototype，如果还没找到，就会继续在__proto__上查找，直到最顶层，找不到即为undefined。这样一层一层往上找，彷佛是一条链子串起来，所以叫做原型链。</p>
</li>
<li>
<p>作用域链<br />
变量取值会到创建这个变量的函数的作用域中取值，如果找不到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p>
</li>
<li>
<p>区别<br />
作用域是对变量而言，原型链是对于对象的属性而言<br />
作用域链的顶层是window，原型链的顶层是Object</p>
</li>
</ol>
<h3><a id="js 判断类型"></a>js 判断类型</h3>
<p>1、typeof<br />
检测不出<mark>null</mark>和<mark>数组</mark>,<mark>对象</mark>，结果都为<code>object</code>，所以<code>typeof</code>常用于检测基本类型</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-number">1</span> <span class="hljs-string">"number"</span>
<span class="hljs-number">124</span> string
<span class="hljs-literal">null</span> <span class="hljs-string">"object"</span> <span class="hljs-comment">//null值表示一个空对象指针</span>
<span class="hljs-literal">true</span> <span class="hljs-string">"boolean"</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-string">"object"</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-string">"object"</span>
</code></div></pre>
<p>2、instanceof<br />
不能检测出<mark>number</mark>、<mark>boolean</mark>、<mark>string</mark>、<mark>undefined</mark>、<mark>null</mark>、<mark>symbol</mark>类型，所以<code>instancof</code>常用于检测复杂类型以及级成关系</p>
<p><code>instanceof</code>运算符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上。</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">const</span> f = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> h = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> i = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

<span class="hljs-built_in">console</span>.log(f, f <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span>); <span class="hljs-comment">//false</span>
<span class="hljs-built_in">console</span>.log(h, h <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(i, i <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>); <span class="hljs-comment">//true</span>
</code></div></pre>
<p>3、constructor<br />
<mark>null</mark>、<mark>undefined</mark>没有<mark>construstor</mark>方法，因此<code>constructor</code>不能判断<mark>undefined</mark>和<mark>null</mark>。但是<code>contructor</code>的指向是可以被改变，所以不安全</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].constructor === <span class="hljs-built_in">Array</span>) <span class="hljs-comment">// ture</span>
</code></div></pre>
<p>4、Object.prototype.toString.call<br />
全类型都可以判断</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-built_in">Object</span>.prototype.toString.call([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) <span class="hljs-comment">// [object Array]</span>
</code></div></pre>
<h3><a id="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h3>
<p>1、普通函数<br />
可以通过bind、call、apply改变this指向<br />
可以使用new</p>
<p>2、箭头函数<br />
本身没有this指向，<br />
它的this在定义的时候继承自外层第一个普通函数的this<br />
被继承的普通函数的this指向改变，箭头函数的this指向会跟着改变<br />
箭头函数外层没有普通函数时，this指向window<br />
不能通过bind、call、apply改变this指向<br />
使用new调用箭头函数会报错，因为箭头函数没有constructor</p>
<h3><a id="document.write和innerHTML的区别"></a>document.write和innerHTML的区别</h3>
<p>document.write 将内容写入页面，清空替换掉原来的内容，会导致重绘<br />
document.innerHTML 将内容写入某个Dom节点，不会重绘</p>
<h3><a id="栈和堆的区别"></a>栈和堆的区别</h3>
<p>1、堆<br />
动态分配内存，内存大小不一，也不会自动释放</p>
<p>2、栈<br />
自动分配相对固定大小的内存空间，并由系统自动释放</p>
<p>3、基本类型都是存储在栈中，每种类型的数据占用的空间的大小是确定的，并由系统自动分配和释放。内存可以及时回收。</p>
<p>4、引用类型的数据都是存储在堆中。准确说是栈中会存储这些数据的地址指针，并指向堆中的具体数据。</p>
<h3><a id="undefined 和 null 区别"></a>undefined 和 null 区别</h3>
<p>1、null<br />
什么都没有，表示一个空对象引用（主动释放一个变量引用的兑现那个，表示一个变量不再指向任何引用地址）<br />
2、undefined<br />
没有设置值的变量，会自动赋值undefined<br />
3、区别<br />
typeof undefined             // undefined<br />
typeof null                  // object<br />
null === undefined           // false<br />
null == undefined            // true</p>
<h3><a id="eval()"></a>eval()</h3>
<p>eval(string) 函数计算<code>JavaScript</code>字符串，并把它作为脚本代码来执行<br />
如果参数是一个表达式，<code>eval()</code>函数将执行表达式；<br />
如果参数是<code>Javascript</code>语句，<code>eval()</code>将执行<code>Javascript</code>语句；<br />
如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。<br />
特殊：eval(&quot;{b:2}&quot;) // 声明一个对象<br />
　eval(&quot;（{b:2}）&quot;) // 返回对象{b:2}</p>
<h3><a id="JS哪些操作会造成内存泄露"></a>JS哪些操作会造成内存泄露</h3>
<p>内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。<br />
1、意外的全局变量<br />
2、闭包<br />
3、没有清理的dom元素；dom元素赋值给变量，又通过removeChild移除dom元素。但是dom元素的引用还在内存中<br />
4、被遗忘的定时器或者回调<br />
<a href="https://www.jianshu.com/p/763ba9562864" target="_blank">扩展文章</a></p>
<h3><a id="什么是闭包，如何使用它，为什么要使用它？"></a>什么是闭包，如何使用它，为什么要使用它？</h3>
<p>（1）闭包就是能够读取其它函数内部变量的函数<br />
（2）使用方法：在一个函数内部创建另一个函数<br />
（3）最大用处有两个：读取其他函数的变量值，让这些变量始终保存在内存中<br />
（4）缺点：会引起内存泄漏（引用无法被销毁，一直存在）</p>
<h3><a id="请解释JSONP的工作原理，以及它为什么不是真正的AJAX"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX</h3>
<p>JSONP 是一种非正式传输协议，允许用户传递一个callback给服务端，然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。<br />
当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。<br />
它们的实质不同<br />
ajax的核心是通过xmlHttpRequest获取非本页内容<br />
jsonp的核心是动态添加script标签调用服务器提供的js脚本<br />
jsonp只支持get请求，ajax支持get和post请求</p>
<h3><a id="请解释一下JavaScript的同源策略"></a>请解释一下JavaScript的同源策略</h3>
<p>同源指协议，域名，端口相同，<br />
同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h2><a id="面试题"></a>面试题</h2>
<h3><a id="写出如下代码的打印结果"></a>写出如下代码的打印结果</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Tom'</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name == <span class="hljs-string">'undefined'</span>) {
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Jack'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Goodbye '</span> + name);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello '</span> + name);
}
})();

<span class="hljs-comment">// name undefined</span>
<span class="hljs-comment">// typeof name undefined</span>
<span class="hljs-comment">// Goodbye Jack</span>
</code></div></pre>
<p>第四行<code>var</code>声明的变量没有块作用域，变量会提升到最近的<code>function</code>作用域的上层，但此时只是声明了变量，并没有赋值，到实际运行了赋值语句之后才有值，在之前值为<code>undefined</code>;</p>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Tom'</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name == <span class="hljs-string">'undefined'</span>) {
  name = <span class="hljs-string">'Jack'</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Goodbye '</span> + name);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello '</span> + name);
}
})();

<span class="hljs-comment">// Hello Tom</span>
</code></div></pre>
<p>1、首先在进入函数作用域当中，获取name属性<br />
2、在当前作用域没有找到name<br />
3、通过作用域链找到最外层，得到name属性<br />
4、执行else的内容，得到Hello Tom</p>
<h3><a id="输出以下代码运行结果"></a>输出以下代码运行结果</h3>
<pre><div class="hljs"><code class="lang-js"><span class="hljs-number">1</span> + <span class="hljs-string">"1"</span>				<span class="hljs-comment">// '11'</span>

<span class="hljs-number">2</span> * <span class="hljs-string">"2"</span>				<span class="hljs-comment">// 4</span>
	
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]			<span class="hljs-comment">// '1,22,1'</span>

<span class="hljs-string">"a"</span> + + <span class="hljs-string">"b"</span>			<span class="hljs-comment">// 'aNaN'</span>
</code></div></pre>
<p>1 + “1”<br />
加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来<br />
所以值为：“11”</p>
<p>2 * “2”<br />
乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值</p>
<p>[1, 2] + [2, 1]<br />
Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。<br />
所以两个数组对象的toString方法相加，值为：“1,22,1”</p>
<p>“a” + + “b”<br />
后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。<br />
所以值为：“aNaN”</p>
<p>以上均参考：《Javascript高级程序设计》</p>
</div>
</body>
<script src="/js/prism.js"></script>
<script>
    window.onload = function() {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
    }
</script>

</html>